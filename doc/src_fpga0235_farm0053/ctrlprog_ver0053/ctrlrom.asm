;
;	SD card file control program
;
	ORG	0000H
;

FIRMVER:	EQU	0053H

;FIRMVER:	EQU	0E006H	; decode address for debug

INITSP:		EQU	3FFFH
;
; buffer location
;
REG_SDBUF:	EQU	8000H
REG_OFFSET:	EQU	81C6H

BPB_SECBYTE	EQU	800BH
BPB_CLASTSEC:	EQU	800DH
BPB_FATST:	EQU	800EH
BPB_FATNUM	EQU	8010H
BPB_DIRENTRY	EQU	8011H
BPB_FATSEC:	EQU	8016H
BPB_FATVER:	EQU	8039H

;
; register mapping
;
REG_SDCMDST:	EQU	8200H
REG_SDCTRL:	EQU	8201H
REG_SDRDDONE:	EQU	8202H
REG_ROMINIT:	EQU	8203H
REG_SDWP:	EQU	8204H
REG_SDCMDNO:	EQU	8205H
REG_SDADD:	EQU	8206H

REG_BUFAD:	EQU	8210H
REG_BUFSEL:	EQU	8211H
REG_CMTOPEN:	EQU	8212H
REG_SDRD:	EQU	8213H
REG_SDWR:	EQU	8214H
REG_CMTRD:	EQU	8234H
REG_CMTWR:	EQU	8254H

REG_FIFO_0:	EQU	8220H
REG_FIFO_1:	EQU	8240H
REG_FIFO_2:	EQU	8260H
REG_FIFO_3:	EQU	8280H
REG_FIFO_4:	EQU	82A0H
REG_FIFO_5:	EQU	82C0H

FIFO_CMTLEN:	EQU	00H
FIFO_CMTPTR:	EQU	04H
FIFO_CL:	EQU	08H
FIFO_SEC:	EQU	0AH
FIFO_STCL:	EQU	0BH
FIFO_BEFCL:	EQU	0DH
FIFO_DIRCL:	EQU	0FH
FIFO_DIRPOS:	EQU	11H
FIFO_FATNEW:	EQU	13H
FIFO_STAT:	EQU	14H
FIFO_WRADD:	EQU	15H
FIFO_FLOPPY:	EQU	14H
FIFO_CNUM:	EQU	15H
FIFO_FDD:	EQU	1FH

REG_FDD0:	EQU	827FH
REG_FDD1:	EQU	829FH
REG_FDD2:	EQU	82BFH
REG_FDD3:	EQU	82DFH

REG_INTFDD:	EQU	8310H
REG_EXTFDD:	EQU	8340H

FDD_DMACTRL:	EQU	00H
FDD_DMASIZE:	EQU	01H
FDD_ST0:	EQU	10H
FDD_ST1:	EQU	11H
FDD_ST2:	EQU	12H
FDD_RST_C:	EQU	13H
FDD_RST_H:	EQU	14H
FDD_RST_R:	EQU	15H
FDD_RST_N:	EQU	16H
FDD_ENDTRG:	EQU	17H
FDD_COMEND:	EQU	20H
FDD_COMMAND:	EQU	21H
FDD_MT:		EQU	22H
FDD_DNUM:	EQU	23H
FDD_HNUM:	EQU	24H
FDD_IDRC:	EQU	25H
FDD_IDRH:	EQU	26H
FDD_IDRR:	EQU	27H
FDD_IDRN:	EQU	28H
FDD_EOT:	EQU	29H
FDD_GPL:	EQU	2AH
FDD_DTL:	EQU	2BH

REG_FDINT:	EQU	8370H

REG_LCDMODE:	EQU	8400H
REG_LCDADD:	EQU	8401H
REG_LCDDAT:	EQU	8402H
REG_LCDST:	EQU	8403H
REG_LCDDONE:	EQU	8404H
REG_CTRLSEL:	EQU	8410H
REG_CTRLRST:	EQU	8411H
REG_MEM16K:	EQU	8412H
REG_SC4MODE:	EQU	8413H
REG_DBGTRG:	EQU	8414H
REG_MK2MODE:	EQU	8415H
REG_KEYDAT:	EQU	8416H
REG_KEYENB:	EQU	8417H
REG_UARTENB:	EQU	8418H
REG_UARTLEN:	EQU	8419H
REG_EXKANJIENB:	EQU	841CH

REG_FUNCKEY:	EQU	8420H

REG_FPGAVER:	EQU	8440H
REG_FIRMVER:	EQU	8442H

DISKBUF:	EQU	9000H
DISKBUF_U:	EQU	90H

REG_EXTFDDDI:	EQU	9FF0H
REG_EXTFDDDO:	EQU	9FF1H
REG_EXTFDDCIO:	EQU	9FF2H
REG_EXTFDDCNT:	EQU	9FF3H
REG_EXTFDCMAIN:	EQU	9FF4H
REG_EXTFDCDATA:	EQU	9FF5H

EXTWRBUF:	EQU	0A000H
EXTWRBUF_U:	EQU	0A0H
EXTRDBUF:	EQU	0B000H
EXTRDBUF_U:	EQU	0B0H

CTRLATT:	EQU	0C000H
CTRLVRAM:	EQU	0C200H


CMD_RECALB:	EQU	07H
CMD_SEEK:	EQU	0FH
CMD_SENSEINTST:	EQU	08H
CMD_MFMRDDATA:	EQU	46H
CMD_RDDATA:	EQU	06H
CMD_RDDELDATA:	EQU	0CH
CMD_MFMWRDATA:	EQU	45H
CMD_WRDATA:	EQU	05H
CMD_WRDELDATA:	EQU	09H
CMD_RDDIA:	EQU	02H
CMD_RDID:	EQU	0AH
CMD_WRID:	EQU	0DH
CMD_MFMWRID:	EQU	4DH
CMD_SCEQU:	EQU	11H
CMD_SCLOW:	EQU	19H
CMD_SCHIG:	EQU	1DH


;

START:

	LD	SP,INITSP
	LD	A,0FFH
	LD	I,A
	EI
	LD	HL,FIRMVER
	LD	(REG_FIRMVER),HL
	XOR	A
	LD	(REG_DBGTRG),A

		;
	CALL	LCD_INIT
	CALL	SCREENINIT
	CALL	FDUNITINIT
	CALL	UARTINIT
		;
	XOR	A
	LD	(SDMODE),A

		;
	CALL	SDCARD_OPEN
	CALL	SDREGINIT
		;
	LD	DE,ST_EXROM_VAL
	CALL	LD_ST_NOSELECT

		;
		; ROM read
		;
	LD	A,(REG_MK2MODE)
	OR	A
	JR	NZ,RDM2
		;
		; ROM read (6001)
		;
	LD	IX,F_BASICROM60
	LD	HL,0000H
	LD	DE,0002H
	CALL	ROMFILEREAD
	LD	IX,F_CGROM60
	LD	HL,0A000H
	LD	DE,0002H
	CALL	ROMFILEREAD
	JP	READEND

RDM2:	DEC	A
	JR	NZ,RDM3
		;
		; ROM read (mk2)
		;
	LD	IX,F_BASICROM62
	LD	HL,0000H
	LD	DE,0003H
	CALL	ROMFILEREAD
	LD	IX,F_CGROM62
	LD	HL,0A000H
	LD	DE,0003H
	CALL	ROMFILEREAD
	LD	IX,F_CG2ROM62
	LD	HL,08000H
	LD	DE,0003H
	CALL	ROMFILEREAD
	LD	IX,F_KANJIROM62
	LD	HL,0000H
	LD	DE,0004H
	CALL	ROMFILEREAD
	LD	IX,F_VOICEROM62
	LD	HL,0C000H
	LD	DE,0003H
	CALL	ROMFILEREAD
	JR	READEND

RDM3:		;
		; ROM read (66)
		;
	LD	IX,F_BASICROM66
	LD	HL,0000H
	LD	DE,0003H
	CALL	ROMFILEREAD
	LD	IX,F_CGROM66
	LD	HL,0A000H
	LD	DE,0003H
	CALL	ROMFILEREAD
	LD	IX,F_CG2ROM66
	LD	HL,08000H
	LD	DE,0003H
	CALL	ROMFILEREAD
	LD	IX,F_KANJIROM66
	LD	HL,0000H
	LD	DE,0004H
	CALL	ROMFILEREAD
	LD	IX,F_VOICEROM66
	LD	HL,0C000H
	LD	DE,0003H
	CALL	ROMFILEREAD

READEND:
	LD	A,01H
	LD	(EXKANJIEXIST),A
		;
		; EXPAND KANJI ROM
		;
	LD	IX,F_EXKANJIROM
	LD	HL,0000H
	LD	DE,0006H
	CALL	ROMFILEREAD2
	JR	NC,READEND2
	XOR	A
	LD	(EXKANJIEXIST),A

READEND2:
	CALL	ROMINIT

	LD	A,01H
	LD	(REG_SDRDDONE),A

	LD	A,01H
	LD	(SDMODE),A


MAINSTART:
	LD	A,02H
	LD	(SDMODE),A
	CALL	SDCARD_OPEN
	CALL	SDREGINIT
MAINST2:
	LD	A,01H
	LD	(SDMODE),A
	CALL	SDREGINIT
	CALL	SDADDINIT

	CALL	KEYBUFINIT

	XOR	A
	LD	(EXROMFLAG),A
	LD	(REG_KEYENB),A

;
; main loop
;
MLP10:
	CALL	KEYDET
	LD	A,(FUNCPUSH+1)
	AND	08H
	JR	Z,MLP11

;
; F11 (reset)
;
	LD	HL,REG_CTRLSEL
	LD	(HL),01H
	LD	(HL),00H

	LD	HL,P6TCMDENB
	LD	A,(HL)
	XOR	01H
	LD	(HL),A
	XOR	A
	LD	(REG_KEYENB),A
	LD	(EXTFDDST),A
	LD	A,0AH
	LD	(REG_EXTFDDCNT),A	; reset RFD
	LD	A,0CH
	LD	(REG_EXTFDDCNT),A	; reset DAC

	JR	MLP10

MLP11:
	CALL	DETSDEJECT
	CALL	CMTREADWAIT
	CALL	CMTWRITEWAIT
	CALL	P6TKEYWAIT
	CALL	EXTDISKWAIT

	LD	IX,REG_INTFDD
	CALL	DISKWAIT
	LD	IX,REG_EXTFDD
	CALL	DISKWAIT

	LD	A,(CTRLNOW)
	AND	10H
	JR	Z,MLP10
	LD	A,(CTRLPUSH)
	AND	10H

	CALL	NZ,PAGE0INIT

;
; control panel display
;
MLP12:

	CALL	DISPPAGE
	CALL	DISPCUR

	CALL	KEYINPAGE

	JR	MLP10



;
; page # keyin process
;
KEYINPAGE:
	LD	A,(PAGENUM)
	OR	A
	JP	Z,KEYINPAGE0
	CP	01H
	JP	Z,KEYINPAGE1
	CP	02H
	JP	Z,KEYINPAGE2

	RET

;
; page 0 keyin process
;
KEYINPAGE0:

	LD	HL,FUNCPUSH
		; F7 - F0,ESC

	INC	HL
		; TAB,RETURN,SPACE,F12 - F8

	BIT	5,(HL)
	JR	Z,KP0LS

PAGE2INIT:
	LD	A,02H
	LD	(PAGENUM),A
	DEC	A
	LD	(PAGEREDRAW),A
	LD	(CURSORREDRAW),A
	LD	HL,PAGE2CURDATA
	LD	DE,CURSOR_ADD
	LD	BC,0003H
	LDIR
	RET

KP0LS:	BIT	6,(HL)
	JP	Z,KP0L0

;
; return
;
	LD	A,01H
	LD	(PAGEREDRAW),A
	LD	(CURSORREDRAW),A

	LD	HL,(CURSOR_ADD)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	A,H
KP0L00:	SUB	03H
	JR	NZ,KP0L01

	XOR	A
	LD	(BEFPAGENUM),A
	LD	A,04H
	LD	(FILESEL),A
	CALL	FILESELINIT
	RET

KP0L01:	CP	01H
	JR	NZ,KP0L02

	LD	HL,REG_CMTRD
	LD	(HL),02H
	LD	(HL),00H
	LD	A,(READFLAG)
	OR	A
	RET	Z

	LD	HL,(REG_FIFO_0+FIFO_STCL)
	LD	(REG_FIFO_0+FIFO_CL),HL
	XOR	A
	LD	(REG_FIFO_0+FIFO_SEC),A
	INC	A
	LD	(READFLAG),A
	RET

KP0L02:	CP	02H
	JR	NZ,KP0L04

	LD	A,(REG_SDWP)
	OR	A
	RET	NZ
	XOR	A
	LD	(BEFPAGENUM),A
	LD	A,0CH
	LD	(FILESEL),A
	CALL	FILESELINIT
	RET

KP0L04:	CP	04H
	JR	NZ,KP0L05

	LD	HL,REG_MEM16K
	LD	A,(HL)
	XOR	01H
	LD	(HL),A

	LD	HL,REG_CTRLRST
	LD	(HL),01H
	LD	(HL),00H
	RET

KP0L05:	CP	05H
	JR	NZ,KP0L06

	XOR	A
	LD	(BEFPAGENUM),A
	LD	A,05H
	LD	(FILESEL),A
	CALL	FILESELINIT
	RET

KP0L06:	CP	06H
	JR	NZ,KP0L08

	LD	HL,REG_EXKANJIENB
	LD	B,(HL)
	LD	A,(EXKANJIEXIST)
	XOR	B
	LD	(HL),A
	RET

KP0L08:	CP	08H
	JR	NZ,KP0L09

	LD	HL,REG_SC4MODE
	LD	A,(HL)
	BIT	4,A
	JR	NZ,KP0L081
	OR	10H
	AND	0FCH
	LD	(HL),A
	RET

KP0L081:
	AND	03H
	INC	A
	AND	03H
	LD	B,A
	LD	A,(HL)
	JR	NZ,KP0L082
	AND	0EFH
KP0L082:
	AND	0FCH
	OR	B
	LD	(HL),A
	RET

KP0L09:	CP	09H
	RET	NZ

	LD	A,(UART_BAUD)
	INC	A
	CP	18H
	JR	NZ,KP0L91
	XOR	A
	LD	(REG_UARTENB),A
	LD	(UART_BAUD),A
	JR	KP0L92
KP0L91:
	LD	(UART_BAUD),A
	LD	A,01H
	LD	(REG_UARTENB),A
KP0L92:
	LD	A,(UART_BAUD)
	LD	L,A
	ADD	A,A
	ADD	A,L
	LD	L,A
	LD	H,00H
	LD	DE,TB_UARTBAUD
	ADD	HL,DE
	LD	DE,REG_UARTLEN
	LD	BC,0003H
	LDIR

	RET


KP0L0:	INC	HL
		; END,ALT,SHIFT,CTRL,<-,->,v,^

	BIT	0,(HL)
	JR	Z,KP0L1

;
; cursor up
;
	LD	C,0FFH
	JR	PAGE0CURMOV

KP0L1:
	BIT	1,(HL)
	RET	Z

;
; cursor down
;
	LD	C,01H
	JR	PAGE0CURMOV

;
; page 0 keyin sub
;
PAGE0CURMOV:
	LD	A,01H
	LD	(CURSORREDRAW),A

	LD	HL,(CURSOR_ADD)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	A,H
	SUB	03H

	ADD	A,C
	CP	0AH
	RET	NC

	CP	03H
	JR	NZ,P0CL0
	ADD	A,C
P0CL0:
	CP	07H
	JR	NZ,P0CL2
	ADD	A,C
P0CL2:
	LD	B,A
	ADD	A,A
	ADD	A,B
	LD	E,A
	LD	D,00H
	LD	HL,PAGE0CURDATA
	ADD	HL,DE
	LD	DE,CURSOR_ADD
	LD	BC,0003H
	LDIR

	RET

;
; page 0 keyin sub
; file selector initialize
;
FILESELINIT:
	LD	HL,0000H
	LD	(DIRCL),HL
	DEC	HL
	LD	(DIRPOS),HL
	LD	A,01H
	LD	(PAGENUM),A
	CALL	SDADDINIT
		;
	LD	A,(FILESEL)
	CP	04H
	JR	NZ,FSIL1
		;
	LD	IY,REG_FIFO_0
	XOR	A
	LD	(REG_BUFAD),A
	RET
FSIL1:	CP	05H
	JR	NZ,FSIL2
		;
	LD	IY,REG_FIFO_0
	XOR	A
	LD	(REG_BUFAD),A
	RET
FSIL2:	CP	06H
	JR	NZ,FSIL3
		;
	LD	IY,REG_FIFO_2
	LD	A,04H
	LD	(REG_BUFAD),A
	RET
FSIL3:	CP	07H
	JR	NZ,FSIL4
		;
	LD	IY,REG_FIFO_3
	LD	A,05H
	LD	(REG_BUFAD),A
	RET
FSIL4:	CP	0CH
	JR	NZ,FSIL5
		;
	LD	IY,REG_FIFO_1
	LD	A,01H
	LD	(REG_BUFAD),A
	RET
FSIL5:	CP	0EH
	JR	NZ,FSIL6
		;
	LD	IY,REG_FIFO_4
	LD	A,06H
	LD	(REG_BUFAD),A
	RET
FSIL6:	CP	0FH
	JR	NZ,FSIL7
		;
	LD	IY,REG_FIFO_5
	LD	A,07H
	LD	(REG_BUFAD),A
	RET
FSIL7:	JR	FSIL7

;
; page 1 keyin process
;
KEYINPAGE1:

	LD	HL,FUNCPUSH
		; F7 - F0,ESC

	BIT	0,(HL)
	JR	Z,KP1L0

;
; ESC
;
PAGEINIT:
	LD	A,(BEFPAGENUM)
	OR	A
	JP	NZ,PAGE2INIT

PAGE0INIT:
	XOR	A
	LD	(PAGENUM),A
	INC	A
	LD	(PAGEREDRAW),A
	LD	(CURSORREDRAW),A

	LD	HL,PAGE0CURDATA
	LD	DE,CURSOR_ADD
	LD	BC,0003H
	LDIR

	RET

KP1L0:	INC	HL
		; TAB,RETURN,SPACE,F12 - F8

	BIT	5,(HL)
	JR	Z,KP1L1

;
; space
;
PAGE1REDRAW:
	LD	A,01H
	LD	(PAGENUM),A
	LD	(PAGEREDRAW),A
	LD	(CURSORREDRAW),A
	RET

KP1L1:	BIT	6,(HL)
	JP	Z,KP1L2

;
; return
;
	LD	HL,(CURSOR_ADD)
	CALL	CUR2BUF
	INC	HL
	LD	A,H
	OR	L
	DEC	HL
	JR	NZ,KP1L1_SEL1

		;
		; file "no select"
		;
KP1L1_NOSELECT:
	LD	A,(FILESEL)
	CP	04H
	JR	NZ,KP1L1_NOSEL1
		;
		; CMT load "no select"
		;
	CALL	SDREGINIT_0

	LD	DE,ST_CMTREAD_VAL

KP1L1_NOSELEND:
	CALL	LD_ST_NOSELECT
	CALL	PAGEINIT
	RET

KP1L1_NOSEL1:
	CP	05H
	JR	NZ,KP1L1_NOSEL2
		;
		; EXT.ROM "no select"
		;
	LD	A,01H
	LD	(REG_CTRLRST),A
	CALL	ROMINIT
	XOR	A
	LD	(REG_CTRLRST),A

	CALL	SDREGINIT_0

	XOR	A
	LD	(EXROMFLAG),A

	LD	DE,ST_EXROM_VAL
	JR	KP1L1_NOSELEND

KP1L1_NOSEL2:
	CP	0CH
	JR	NZ,KP1L1_NOSEL3
		;
		; CMT save "no select"
		;
	CALL	SDREGINIT_1

	LD	DE,ST_CMTWRITE_VAL
	JR	KP1L1_NOSELEND

KP1L1_NOSEL3:
	CP	06H
	JR	NZ,KP1L1_NOSEL4
		;
		; INT FDD#0 "no select"
		;
	LD	IY,REG_FIFO_2
	LD	DE,ST_FDD0INTFILE_VAL

KP1L1_NOSELFDD:
	CALL	SDREGINIT_2
	JR	KP1L1_NOSELEND

KP1L1_NOSEL4:
	CP	07H
	JR	NZ,KP1L1_NOSEL5
		;
		; INT FDD#1 "no select"
		;
	LD	IY,REG_FIFO_3
	LD	DE,ST_FDD1INTFILE_VAL
	JR	KP1L1_NOSELFDD

KP1L1_NOSEL5:
	CP	0EH
	JR	NZ,KP1L1_NOSEL6
		;
		; EXT FDD#0 "no select"
		;
	LD	IY,REG_FIFO_4
	LD	DE,ST_FDD0EXTFILE_VAL
	JR	KP1L1_NOSELFDD

KP1L1_NOSEL6:
	CP	0FH
	JR	NZ,KP1L1_NOSEL7
		;
		; EXT FDD#1 "no select"
		;
	LD	IY,REG_FIFO_5
	LD	DE,ST_FDD1EXTFILE_VAL
	JR	KP1L1_NOSELFDD

KP1L1_NOSEL7:
	JR	KP1L1_NOSEL7

		;
		; file / directory judge
		;
KP1L1_SEL1:
	LD	(DIRPOS),HL
		;
	LD	A,01H
	LD	(REG_SDCTRL),A
	CALL	READ_DIRFILE
	XOR	A
	LD	(REG_SDCTRL),A
		;
	LD	BC,000BH
	ADD	HL,BC
	LD	A,(HL)
	LD	BC,000FH
	ADD	HL,BC
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	DEC	HL
	AND	10H
	JR	Z,KP1L11

		;
		; select directory
		;
	EX	DE,HL
	LD	(DIRCL),HL
	LD	A,H
	OR	L
	LD	HL,0FFFFH
	JR	Z,KP1L1_ROOT
	INC	HL
KP1L1_ROOT:
	LD	(DIRPOS),HL
	CALL	PAGE1REDRAW
	RET

KP1L11:
	LD	A,(FILESEL)
	CP	04H
	JR	NZ,KP1L1_FS1

		;
		; CMT load file name
		;
	CALL	SDREGINIT_0
	CALL	SETFILEPARA

	LD	A,01H
	LD	(READFLAG),A

	LD	DE,ST_CMTREAD_VAL
	LD	HL,(CURSOR_ADD)
	LD	BC,CTRLVRAM
	ADD	HL,BC
	PUSH	HL
	LD	BC,000CH
	LDIR

	XOR	A
	LD	(P6TFILEREAD),A

	POP	HL
	LD	DE,0009H
	ADD	HL,DE
	LD	DE,ST_P6T
	LD	B,03H
	CALL	CP_MHL_MDE
	JR	NZ,KP1L1_NOP6T

	CALL	READP6T
	LD	(P6TFILEREAD),A

KP1L1_NOP6T:
	CALL	PAGEINIT

	RET

KP1L1_FS1:
	CP	05H
	JR	NZ,KP1L1_FS2

		;
		; EXT. ROM load file name
		;
	CALL	SDREGINIT_0
	CALL	SETFILEPARA

	LD	DE,ST_EXROM_VAL
	LD	HL,(CURSOR_ADD)
	LD	BC,CTRLVRAM
	ADD	HL,BC
	LD	BC,000CH
	LDIR

	LD	DE,ST_CMTREAD_VAL
	CALL	LD_ST_NOSELECT

	CALL	PAGEINIT


	LD	A,01H
	LD	(REG_CTRLRST),A
		;
	CALL	ROMINIT
		;
	XOR	A
	LD	(REG_BUFAD),A
	LD	(IY+FIFO_CMTPTR+0),00H
	LD	(IY+FIFO_CMTPTR+1),0C0H
	LD	(IY+FIFO_CMTPTR+2),02H
	LD	(IY+FIFO_CMTPTR+3),00H
		;
	CALL	FILEREAD
		;
	XOR	A
	LD	(REG_CTRLRST),A
		;
	CALL	SDREGINIT_0
		;
	LD	A,01H
	LD	(EXROMFLAG),A

	RET


KP1L1_FS2:
	CP	0CH
	JR	NZ,KP1L1_FS3

		;
		; CMT save file name
		;
	CALL	SDREGINIT_1
	CALL	SETFILEPARA

	LD	DE,ST_CMTWRITE_VAL
	LD	HL,(CURSOR_ADD)
	LD	BC,CTRLVRAM
	ADD	HL,BC
	LD	BC,000CH
	LDIR

	CALL	PAGEINIT

	LD	A,04H
	LD	(REG_CMTWR),A

	LD	A,01H
	LD	(WRITEFLAG),A

	RET


KP1L1_FS3:
	CP	06H
	JP	NZ,KP1L1_FS4

		;
		; INT FDD#0 file name
		;
	LD	IY,REG_FIFO_2
	LD	DE,ST_FDD0INTFILE_VAL

KP1L1_FDD:
	PUSH	DE
	CALL	SDREGINIT_2
	CALL	SETFILEPARA

		;
		; read only -> write protect set
		;
	LD	BC,0014H
	OR	A
	SBC	HL,BC
	LD	A,(HL)
	AND	01H
	JR	Z,KP1L1_FDD_RW
	LD	A,08H
	LD	(IY+FIFO_FLOPPY),A

KP1L1_FDD_RW:
	LD	HL,(CURSOR_ADD)
	LD	BC,CTRLVRAM
	ADD	HL,BC
	LD	BC,000CH
	LDIR

	POP	DE

		;
		; file length check (>= 0x000002B0)
		;
	LD	A,(IY+FIFO_CMTLEN+3)
	OR	A
	JR	NZ,KP1L1_LEN_OK
	LD	A,(IY+FIFO_CMTLEN+2)
	OR	A
	JR	NZ,KP1L1_LEN_OK
	LD	A,(IY+FIFO_CMTLEN+1)
	OR	A
	JR	Z,KP1L1_LEN_0
	CP	02H
	JP	C,KP1L1_NOSELFDD
	JR	NZ,KP1L1_LEN_OK
	LD	A,(IY+FIFO_CMTLEN+0)
	CP	0B0H
	JP	C,KP1L1_NOSELFDD

KP1L1_LEN_OK:
	PUSH	DE
	LD	A,01H
	LD	(REG_SDCTRL),A
	LD	(REG_BUFSEL),A

	LD	BC,0000H
	LD	DE,001AH
	CALL	JMPREADPTR

	CALL	READ1BYTE
	LD	C,A		; disk write protect
	CALL	READ1BYTE
	LD	B,A		; disk type
	PUSH	BC

		;
		; disk size compare
		;
	CALL	READ1BYTE
	LD	B,(IY+FIFO_CMTLEN+0)
	CP	B
	JR	NZ,KP1L1_LEN_NG
	CALL	READ1BYTE
	LD	B,(IY+FIFO_CMTLEN+1)
	CP	B
	JR	NZ,KP1L1_LEN_NG
	CALL	READ1BYTE
	LD	B,(IY+FIFO_CMTLEN+2)
	CP	B
	JR	NZ,KP1L1_LEN_NG
	CALL	READ1BYTE
	LD	B,(IY+FIFO_CMTLEN+3)
	CP	B
	JR	NZ,KP1L1_LEN_NG

	XOR	A
	LD	(REG_SDCTRL),A
	POP	BC
	POP	DE

KP1L1_FDD_1:
	SET	0,(IY+FIFO_FLOPPY)
	LD	A,B
	OR	A
	JR	Z,KP1L1_FDD_2
	SET	1,(IY+FIFO_FLOPPY)

KP1L1_FDD_2:
	LD	A,C
	OR	A
	JR	Z,KP1L1_FDD_3
	SET	3,(IY+FIFO_FLOPPY)

KP1L1_FDD_3:
	CALL	PAGEINIT
	RET


KP1L1_LEN_NG:
	XOR	A
	LD	(REG_SDCTRL),A
	POP	BC
	POP	DE
	JP	KP1L1_NOSELFDD


KP1L1_LEN_0:
	LD	A,(IY+FIFO_CMTLEN+0)
	OR	A
	JP	NZ,KP1L1_NOSELFDD

	LD	BC,0000H
	JR	KP1L1_FDD_1


KP1L1_FS4:
	CP	07H
	JR	NZ,KP1L1_FS5

		;
		; INT FDD#1 file name
		;
	LD	IY,REG_FIFO_3
	LD	DE,ST_FDD1INTFILE_VAL
	JP	KP1L1_FDD

KP1L1_FS5:
	CP	0EH
	JR	NZ,KP1L1_FS6

		;
		; EXT FDD#0 file name
		;
	LD	IY,REG_FIFO_4
	LD	DE,ST_FDD0EXTFILE_VAL
	JP	KP1L1_FDD

KP1L1_FS6:
	CP	0FH
	JR	NZ,KP1L1_FS7

		;
		; EXT FDD#1 file name
		;
	LD	IY,REG_FIFO_5
	LD	DE,ST_FDD1EXTFILE_VAL
	JP	KP1L1_FDD


KP1L1_FS7:
	JR	NZ,KP1L1_FS7


KP1L2:	INC	HL
		; END,ALT,SHIFT,CTRL,<-,->,v,^

	BIT	0,(HL)
	JR	Z,KP1L3

;
; cursor up
;
	LD	A,01H
	LD	(CURSORREDRAW),A

	LD	HL,(CURSOR_ADD)
	EX	DE,HL
	LD	HL,0072H
	OR	A
	SBC	HL,DE
	RET	NC

	LD	HL,0020H
	EX	DE,HL
	OR	A
	SBC	HL,DE
	LD	(CURSOR_ADD),HL

	RET

KP1L3:
	BIT	1,(HL)
	JR	Z,KP1L4

;
; cursor down
;
	LD	A,01H
	LD	(CURSORREDRAW),A

	LD	HL,(CURSOR_ADD)
	EX	DE,HL
	LD	HL,0182H-1
	OR	A
	SBC	HL,DE
	RET	C

	LD	HL,(CURSOR_ADD)
	LD	DE,0020H
	ADD	HL,DE
	CALL	CUR2CHK
	RET	Z

	LD	HL,(CURSOR_ADD)
	LD	DE,0020H
	ADD	HL,DE
	LD	(CURSOR_ADD),HL
	RET

KP1L4:
	BIT	2,(HL)
	JR	Z,KP1L5

;
; cursor right
;
	LD	A,01H
	LD	(CURSORREDRAW),A

	LD	HL,(CURSOR_ADD)
	LD	A,L
	AND	1FH
	CP	12H
	RET	NC

	LD	HL,(CURSOR_ADD)
	LD	DE,0010H
	ADD	HL,DE
	CALL	CUR2CHK
	RET	Z

	LD	HL,(CURSOR_ADD)
	LD	DE,0010H
	ADD	HL,DE
	LD	(CURSOR_ADD),HL

	RET

KP1L5:
	BIT	3,(HL)
	RET	Z

;
; cursor left
;
	LD	A,01H
	LD	(CURSORREDRAW),A

	LD	HL,(CURSOR_ADD)
	LD	A,L
	AND	1FH
	CP	02H+1
	RET	C

	LD	DE,0010H
	OR	A
	SBC	HL,DE
	LD	(CURSOR_ADD),HL

	RET



;
; cursor position -> file buffer positon (keyin 1 sub)
;
; HL <- cursor position
;
; RETURN HL:file buffer position
;
CUR2BUF:
	LD	DE,0062H
	OR	A
	SBC	HL,DE
	SRL	H
	RR	L
	SRL	H
	RR	L
	SRL	H
	RR	L
	LD	DE,FILEPTR_BUF
	ADD	HL,DE
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	RET

;
; cursor position -> file buffer positon (keyin 1 sub)
;
; HL <- cursor position
;
; RETURN Zflag set:file NULL
;
CUR2CHK:
	CALL	CUR2BUF
	INC	HL
	LD	A,L
	OR	H
	RET

;
; set file parameter
; IX <= file name address
;
SETFILEPARA:
	PUSH	HL
	LD	HL,(DIRCL)
	LD	(IY+FIFO_DIRCL+0),L
	LD	(IY+FIFO_DIRCL+1),H
	LD	HL,(DIRPOS)
	LD	(IY+FIFO_DIRPOS+0),L
	LD	(IY+FIFO_DIRPOS+1),H
	POP	HL

SETFILEPARA2:
	LD	A,(HL)
	LD	(IY+FIFO_CL+0),A
	LD	(IY+FIFO_STCL+0),A
	INC	HL
	LD	A,(HL)
	LD	(IY+FIFO_CL+1),A
	LD	(IY+FIFO_STCL+1),A
	INC	HL
	LD	A,(HL)
	LD	(IY+FIFO_CMTLEN+0),A
	INC	HL
	LD	A,(HL)
	LD	(IY+FIFO_CMTLEN+1),A
	INC	HL
	LD	A,(HL)
	LD	(IY+FIFO_CMTLEN+2),A
	INC	HL
	LD	A,(HL)
	LD	(IY+FIFO_CMTLEN+3),A

	RET

;
; page 2 keyin process
;
KEYINPAGE2:

	LD	HL,FUNCPUSH
		; F7 - F0,ESC

	INC	HL
		; TAB,RETURN,SPACE,F12 - F8

	BIT	5,(HL)
	JP	NZ,PAGE0INIT

KP2LS:	BIT	6,(HL)
	JP	Z,KP2L0

;
; return
;
	LD	A,01H
	LD	(PAGEREDRAW),A
	LD	(CURSORREDRAW),A

	LD	HL,(CURSOR_ADD)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	A,H
KP2L00:	SUB	03H
	JR	NZ,KP2L01

	LD	A,(REG_MK2MODE)
	CP	02H
	RET	NZ
	LD	A,(REG_FDD0)
	AND	01H
	XOR	01H
	LD	(REG_FDD0),A
	RET	NZ
	LD	A,06H
	LD	(FILESEL),A
	CALL	KP1L1_NOSELECT
	RET


;	LD	A,(REG_FDD0)
;	AND	07H
;	ADD	A,02H
;	LD	(REG_FDD0),A
;	BIT	0,A
;	JR	NZ,KP2L00_0
;	LD	A,01H
;	LD	(REG_FDD0),A
;	RET
;KP2L00_0:
;	CP	09H
;	RET	NZ
;	XOR	A
;	LD	(REG_FDD0),A
;	RET


KP2L01:	CP	01H
	JR	NZ,KP2L02

	LD	A,(REG_FDD0)
	OR	A
	RET	Z
	LD	A,02H
	LD	(BEFPAGENUM),A
	LD	A,06H
	LD	(FILESEL),A
	CALL	FILESELINIT
	RET


KP2L02:	CP	02H
	JR	NZ,KP2L03

	LD	A,(REG_MK2MODE)
	CP	02H
	RET	NZ
	LD	A,(REG_FDD1)
	AND	01H
	XOR	01H
	LD	(REG_FDD1),A
	RET	NZ
	LD	A,07H
	LD	(FILESEL),A
	CALL	KP1L1_NOSELECT
	RET

;	LD	A,(REG_FDD1)
;	AND	07H
;	ADD	A,02H
;	LD	(REG_FDD1),A
;	BIT	0,A
;	JR	NZ,KP2L02_0
;	LD	A,01H
;	LD	(REG_FDD1),A
;	RET
;KP2L02_0:
;	CP	09H
;	RET	NZ
;	XOR	A
;	LD	(REG_FDD1),A
;	RET


KP2L03:	CP	03H
	JR	NZ,KP2L05

	LD	A,(REG_FDD1)
	OR	A
	RET	Z
	LD	A,02H
	LD	(BEFPAGENUM),A
	LD	A,07H
	LD	(FILESEL),A
	CALL	FILESELINIT
	RET


KP2L05:	CP	05H
	JR	NZ,KP2L06

	LD	A,(REG_FDD2)
	AND	01H
	XOR	01H
	LD	(REG_FDD2),A
	RET	NZ
	LD	A,0EH
	LD	(FILESEL),A
	CALL	KP1L1_NOSELECT
	RET

;	LD	A,(REG_FDD2)
;	AND	07H
;	ADD	A,02H
;	LD	(REG_FDD2),A
;	BIT	0,A
;	JR	NZ,KP2L05_0
;	LD	A,01H
;	LD	(REG_FDD2),A
;	RET
;KP2L05_0:
;	CP	09H
;	RET	NZ
;	XOR	A
;	LD	(REG_FDD2),A
;	RET

KP2L06:	CP	06H
	JR	NZ,KP2L07

	LD	A,(REG_FDD2)
	OR	A
	RET	Z
	LD	A,02H
	LD	(BEFPAGENUM),A
	LD	A,0EH
	LD	(FILESEL),A
	CALL	FILESELINIT
	RET


KP2L07:	CP	07H
	JR	NZ,KP2L08

	LD	A,(REG_FDD3)
	AND	01H
	XOR	01H
	LD	(REG_FDD3),A
	RET	NZ
	LD	A,0FH
	LD	(FILESEL),A
	CALL	KP1L1_NOSELECT
	RET

;	LD	A,(REG_FDD3)
;	AND	07H
;	ADD	A,02H
;	LD	(REG_FDD3),A
;	BIT	0,A
;	JR	NZ,KP2L07_0
;	LD	A,01H
;	LD	(REG_FDD3),A
;	RET
;KP2L07_0:
;	CP	09H
;	RET	NZ
;	XOR	A
;	LD	(REG_FDD3),A
;	RET


KP2L08:	CP	08H
	RET	NZ

	LD	A,(REG_FDD3)
	OR	A
	RET	Z
	LD	A,02H
	LD	(BEFPAGENUM),A
	LD	A,0FH
	LD	(FILESEL),A
	CALL	FILESELINIT
	RET


KP2L0:	INC	HL
		; END,ALT,SHIFT,CTRL,<-,->,v,^

	BIT	0,(HL)
	JR	Z,KP2L1

;
; cursor up
;
	LD	C,0FFH
	JR	PAGE2CURMOV

KP2L1:
	BIT	1,(HL)
	RET	Z

;
; cursor down
;
	LD	C,01H
	JR	PAGE2CURMOV

;
; page 2 keyin sub
;
PAGE2CURMOV:
	LD	A,01H
	LD	(CURSORREDRAW),A

	LD	HL,(CURSOR_ADD)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	A,H
	SUB	03H

	ADD	A,C
	CP	09H
	RET	NC

	CP	04H
	JR	NZ,P2CL0
	ADD	A,C
P2CL0:
	LD	B,A
	ADD	A,A
	ADD	A,B
	LD	E,A
	LD	D,00H
	LD	HL,PAGE2CURDATA
	ADD	HL,DE
	LD	DE,CURSOR_ADD
	LD	BC,0003H
	LDIR

	RET


;
; page # display
;
DISPPAGE:
	LD	A,(PAGEREDRAW)
	OR	A
	RET	Z

	CALL	SCREENINIT

	XOR	A
	LD	(PAGEREDRAW),A
	INC	A
	LD	(CURSORREDRAW),A

	LD	A,(PAGENUM)
	OR	A
	JP	Z,DISPPAGE0
	CP	01H
	JP	Z,DISPPAGE1
	CP	02H
	JP	Z,DISPPAGE2

	RET


;
; page 0 display
;
DISPPAGE0:
	LD	HL,ST_32
	LD	A,(REG_MEM16K)
	OR	A
	JR	Z,DP0L2
	LD	HL,ST_16
DP0L2:
	LD	A,(REG_MK2MODE)
	OR	A
	JR	Z,DP0L21
	LD	HL,ST_64
	LD	A,(REG_MEM16K)
	OR	A
	JR	Z,DP0L21
	LD	HL,ST_128
DP0L21:
	LD	DE,ST_MEMSIZE_VAL
	LD	BC,0003H
	LDIR

	LD	HL,ST_OFF
	LD	A,(REG_EXKANJIENB)
	OR	A
	JR	Z,DPOL3
	LD	HL,ST_ON
DPOL3:
	LD	DE,ST_EXKANJI_VAL
	LD	BC,0004H
	LDIR

	LD	HL,ST_SC4COLOFF
	LD	A,(REG_SC4MODE)
	BIT	4,A
	JR	Z,DP0L5
	LD	HL,ST_SC4COL0
	AND	03H
	JR	Z,DP0L5
	LD	HL,ST_SC4COL1
	CP	01H
	JR	Z,DP0L5
	LD	HL,ST_SC4COL2
	CP	02H
	JR	Z,DP0L5
	LD	HL,ST_SC4COL3
DP0L5:	LD	DE,ST_SC4COL_VAL
	LD	BC,0008H
	LDIR

	LD	A,(UART_BAUD)
	LD	L,A
	LD	E,L
	LD	H,00H
	LD	D,H
	ADD	HL,HL		; x2
	ADD	HL,DE		; x3
	ADD	HL,HL		; x6
	ADD	HL,HL		; x12
	ADD	HL,DE		; x13
	LD	DE,ST_UARTBAUD
	ADD	HL,DE
	LD	DE,ST_UART_VAL
	LD	BC,000DH
	LDIR

	LD	HL,ST_CMTREAD
	CALL	PRINTSTRING
	LD	HL,ST_CMTREW
	CALL	PRINTSTRING
	LD	HL,ST_CMTWRITE
	CALL	PRINTSTRING
	LD	HL,ST_MEMSIZE
	CALL	PRINTSTRING
	LD	HL,ST_EXROM
	CALL	PRINTSTRING
	LD	HL,ST_EXKANJI
	CALL	PRINTSTRING
	LD	HL,ST_SC4COL
	CALL	PRINTSTRING
	LD	HL,ST_UART
	CALL	PRINTSTRING

	RET

;
; page 1 display
;
DISPPAGE1:
	LD	A,01H
	LD	(REG_SDCTRL),A

	LD	B,28H
	LD	HL,FILEPTR_BUF
P1LP10:	LD	(HL),0FFH
	INC	HL
	DJNZ	P1LP10
		;
	LD	HL,0062H
	LD	(ST_FNAME),HL
		;
P1LP11:	LD	B,14H
	LD	DE,FILEPTR_BUF
P1LP13:	PUSH	BC
	PUSH	DE
P1LP15: LD	HL,(DIRPOS)
	INC	HL
	LD	A,H
	OR	L
	JR	NZ,P1LP151
		;
		; "NO SELECT"
		;
	LD	(DIRPOS),HL
	LD	DE,ST_FNAME_VAL
	CALL	LD_ST_NOSELECT
	JR	P1LP18

P1LP131:JR	P1LP13

P1LP151:
	CALL	READ_DIRFILE

	PUSH	HL
	LD	HL,(DIRPOS)
	LD	A,H
	INC	HL
	LD	(DIRPOS),HL
	POP	HL
	CP	02H
	JR	NC,P1LP14

	LD	A,(HL)
	OR	A
	JR	Z,P1LP14
	CP	05H
	JR	Z,P1LP15
	CP	0E5H
	JR	Z,P1LP15
	CP	'.'
	JR	NZ,P1LP16
	INC	HL
	LD	A,(HL)
	DEC	HL
	CP	' '
	JR	Z,P1LP15

P1LP16: LD	DE,ST_FNAME_VAL
	LD	BC,0008H
	LDIR
	LD	A,'.'
	LD	(DE),A
	INC	DE
	LD	BC,0003H
	LDIR
	LD	A,(HL)
	LD	B,A
	AND	0EH
	JR	NZ,P1LP15
	LD	A,(FILESEL)
	CP	0CH
	JR	NZ,P1LP161
	LD	A,B
	AND	01H
	JR	NZ,P1LP15
P1LP161:
	LD	A,B
	AND	10H
	JR	Z,P1LP18
	LD	A,'='
	DEC	DE
	LD	(DE),A
	DEC	DE
	LD	(DE),A
	DEC	DE
	LD	(DE),A
	DEC	DE
	LD	(DE),A

P1LP18:	LD	HL,(DIRPOS)
	DEC	HL
	EX	DE,HL
	POP	HL
	PUSH	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D

	LD	HL,ST_FNAME
	CALL	PRINTSTRING

	LD	HL,(ST_FNAME)
	LD	DE,0010H
	ADD	HL,DE
	LD	(ST_FNAME),HL
	POP	DE
	INC	DE
	INC	DE
	POP	BC
	DJNZ	P1LP131

P1LP12:	LD	HL,0062H
	LD	(CURSOR_ADD),HL
	LD	A,0CH
	LD	(CURSOR_LEN),A
	XOR	A
	LD	(REG_SDCTRL),A
	RET

		;
		; directory entry end
		;
P1LP14:	POP	DE
	POP	BC
	LD	HL,(DIRCL)
	LD	A,H
	OR	L
	LD	HL,0FFFFH
	JR	Z,P1LP141
	INC	HL
P1LP141:
	LD	(DIRPOS),HL
	LD	A,B
	CP	14H
	JP	Z,P1LP11
	JR	P1LP12


;
; page 2 display
;
DISPPAGE2:

	LD	HL,ST_NOUSE
		;
	LD	A,(REG_FDD0)
	BIT	0,A
	JR	Z,DP2LF0
		;
	AND	A,06H
	LD	HL,ST_1D
	JR	Z,DP2LF0
		;
	LD	HL,ST_1DD
	CP	02H
	JR	Z,DP2LF0
		;
	LD	HL,ST_2D
	CP	04H
	JR	Z,DP2LF0
		;
	LD	HL,ST_2DD
		;
DP2LF0:	LD	DE,ST_FDD0INTSET_VAL
	LD	BC,0006H
	LDIR

	LD	HL,ST_NOUSE
		;
	LD	A,(REG_FDD1)
	BIT	0,A
	JR	Z,DP2LF1
		;
	AND	A,06H
	LD	HL,ST_1D
	JR	Z,DP2LF1
		;
	LD	HL,ST_1DD
	CP	02H
	JR	Z,DP2LF1
		;
	LD	HL,ST_2D
	CP	04H
	JR	Z,DP2LF1
		;
	LD	HL,ST_2DD
		;
DP2LF1:	LD	DE,ST_FDD1INTSET_VAL
	LD	BC,0006H
	LDIR

	LD	HL,ST_NOUSE
		;
	LD	A,(REG_FDD2)
	BIT	0,A
	JR	Z,DP2LF2
		;
	AND	A,06H
	LD	HL,ST_1D
	JR	Z,DP2LF2
		;
	LD	HL,ST_1DD
	CP	02H
	JR	Z,DP2LF2
		;
	LD	HL,ST_2D
	CP	04H
	JR	Z,DP2LF2
		;
	LD	HL,ST_2DD
		;
DP2LF2:	LD	DE,ST_FDD0EXTSET_VAL
	LD	BC,0006H
	LDIR

	LD	HL,ST_NOUSE
		;
	LD	A,(REG_FDD3)
	BIT	0,A
	JR	Z,DP2LF3
		;
	AND	A,06H
	LD	HL,ST_1D
	JR	Z,DP2LF3
		;
	LD	HL,ST_1DD
	CP	02H
	JR	Z,DP2LF3
		;
	LD	HL,ST_2D
	CP	04H
	JR	Z,DP2LF3
		;
	LD	HL,ST_2DD
		;
DP2LF3:	LD	DE,ST_FDD1EXTSET_VAL
	LD	BC,0006H
	LDIR


	LD	HL,ST_FDD0INTSET
	CALL	PRINTSTRING
	LD	HL,ST_FDD0INTFILE
	CALL	PRINTSTRING
	LD	HL,ST_FDD1INTSET
	CALL	PRINTSTRING
	LD	HL,ST_FDD1INTFILE
	CALL	PRINTSTRING
	LD	HL,ST_FDD0EXTSET
	CALL	PRINTSTRING
	LD	HL,ST_FDD0EXTFILE
	CALL	PRINTSTRING
	LD	HL,ST_FDD1EXTSET
	CALL	PRINTSTRING
	LD	HL,ST_FDD1EXTFILE
	CALL	PRINTSTRING

	RET



;
; cursor display
;
DISPCUR:
	LD	A,(CURSORREDRAW)
	OR	A
	RET	Z

	LD	DE,CTRLATT+41H
	LD	HL,CTRLATT+40H
	LD	BC,017FH

	LD	(HL),22H
	LD	A,(REG_MK2MODE)
	OR	A
	JR	Z,DCL2
	LD	(HL),20H
DCL2:
	LDIR

	LD	A,(CURSOR_LEN)
	LD	B,A
	LD	HL,(CURSOR_ADD)
	LD	DE,CTRLATT
	ADD	HL,DE
DCL1:	LD	(HL),23H
	INC	HL
	DJNZ	DCL1

	XOR	A
	LD	(CURSORREDRAW),A
	RET


;
; screen initialize
;
SCREENINIT:
	LD	DE,CTRLATT+1
	LD	HL,CTRLATT
	LD	BC,0040H
	LD	(HL),20H
	LD	A,(REG_MK2MODE)
	OR	A
	JR	Z,SIL_TOP
	LD	(HL),23H
SIL_TOP:

	LDIR
	LD	BC,0180H
	LD	(HL),22H
	LD	A,(REG_MK2MODE)
	OR	A
	JR	Z,SIL_MID
	LD	(HL),20H
SIL_MID:

	LDIR
	LD	BC,0040H
	LD	(HL),20H
	LD	A,(REG_MK2MODE)
	OR	A
	JR	Z,SIL_BOT
	LD	(HL),23H
SIL_BOT:
	LDIR
	LD	BC,01FFH
	LD	(HL),20H


	LDIR

	LD	HL,(REG_FIRMVER)
	LD	DE,ST_FIRMVER_VAL
	CALL	VER_CONV
	LD	HL,(REG_FPGAVER)
	LD	DE,ST_FPGAVER_VAL
	CALL	VER_CONV

	LD	HL,ST_PC6001F
	LD	A,(REG_MK2MODE)
	OR	A
	JR	Z,SIL_P6
	LD	HL,ST_PC6001FMK2
	CP	01H
	JR	Z,SIL_P6
	LD	HL,ST_PC6601F
SIL_P6:
	CALL	PRINTSTRING
	LD	HL,ST_FPGAVER
	CALL	PRINTSTRING
	LD	HL,ST_FIRMVER
	CALL	PRINTSTRING

	LD	HL,ST_KEYFUNC1
	CALL	PRINTSTRING
	LD	HL,ST_KEYFUNC2
	CALL	PRINTSTRING

	RET

;
; version number convert
;
VER_CONV
	LD	B,02H

VCL1:
	LD	A,H
	AND	0F0H
	RRA
	RRA
	RRA
	RRA
	ADD	A,30H
	CP	3AH
	JR	C,VCL2
	ADD	A,07H
VCL2:	LD	(DE),A
	INC	DE
	LD	A,H
	AND	0FH
	ADD	A,30H
	CP	3AH
	JR	C,VCL3
	ADD	A,07H
VCL3:	LD	(DE),A
	INC	DE
	LD	H,L
	DJNZ	VCL1
	RET


;
; print strings
;
; HL <- pointer of strings with display address
;
PRINTSTRING:
	LD	DE,CTRLVRAM
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	INC	HL
	EX	DE,HL
	ADD	HL,BC
	EX	DE,HL

PSL1:
	LD	A,(HL)
	OR	A
	RET	Z
	LD	(DE),A
	INC	HL
	INC	DE
	JR	PSL1


;
; debug
;
; HL <- print number
;
;PRINTHL:
;	LD	DE,ST_DEBUG_VAL
;	CALL	VER_CONV
;	LD	HL,ST_DEBUG
;	CALL	PRINTSTRING
;	RET


;
; key push detect
;
KEYDET:
	LD	HL,CTRLNOW
	LD	DE,CTRLBEF
	LD	IX,REG_CTRLSEL
	LD	IY,CTRLPUSH
	LD	B,04H

KDLP1:	LD	A,(HL)
	LD	(DE),A
	LD	A,(IX+00H)
	LD	(HL),A
	LD	A,(DE)
	XOR	(HL)
	AND	(HL)
	LD	(IY+00H),A

	INC	HL
	INC	DE
	INC	IY
	LD	A,B
	CP	04H
	JR	NZ,KDLP2
	LD	IX,REG_FUNCKEY-1
KDLP2:	INC	IX
	DJNZ	KDLP1

	RET


;
; read file
;
CMTREADWAIT:
	LD	A,(READFLAG)
	OR	A
	RET	Z
	DEC	A
	JR	NZ,CRWL1

		;
		; read file (new)
		;
	LD	A,(REG_CMTOPEN)
	AND	01H
	RET	Z

	LD	A,01H
	LD	(REG_SDCTRL),A

	XOR	A
	LD	(REG_BUFAD),A
	LD	A,04H
	LD	(FILESEL),A
	LD	IY,REG_FIFO_0
		;
	CALL	FILEREAD

	XOR	A
	LD	(REG_SDCTRL),A
	LD	A,02H
	LD	(READFLAG),A
	RET

		;
		; read file (continue)
		;
CRWL1:
	LD	A,(REG_CMTOPEN)
	AND	01H
	RET	Z

	LD	A,01H
	LD	(REG_SDCTRL),A

	XOR	A
	LD	(REG_BUFAD),A
	LD	A,04H
	LD	(FILESEL),A
	LD	IY,REG_FIFO_0
		;
	CALL	READCONT

	XOR	A
	LD	(REG_SDCTRL),A
	RET


;
; write file
;
CMTWRITEWAIT:
	LD	A,(WRITEFLAG)
	OR	A
	RET	Z
	DEC	A
	JP	NZ,CWW_FL2


		;
		; WRITEFLAG = 1
		;
	LD	A,(REG_CMTOPEN)
	AND	02H
	RET	Z

		;
	LD	A,01H
	LD	(REG_SDCTRL),A
	LD	(REG_BUFAD),A
	LD	IY,REG_FIFO_1

		;
		; get new file length and new start claster
		;
	LD	L,(IY+FIFO_DIRCL+0)
	LD	H,(IY+FIFO_DIRCL+1)
	LD	(DIRCL),HL
	LD	L,(IY+FIFO_DIRPOS+0)
	LD	H,(IY+FIFO_DIRPOS+1)
	LD	(DIRPOS),HL
		;

	CALL	READ_DIRFILE

		;
	LD	BC,001AH
	ADD	HL,BC

	CALL	SETFILEPARA2

	LD	A,(IY+FIFO_CMTLEN+0)
	LD	(IY+FIFO_CMTPTR+0),A
	LD	A,(IY+FIFO_CMTLEN+1)
	LD	(IY+FIFO_CMTPTR+1),A
	LD	A,(IY+FIFO_CMTLEN+2)
	LD	(IY+FIFO_CMTPTR+2),A
	LD	A,(IY+FIFO_CMTLEN+3)
	LD	(IY+FIFO_CMTPTR+3),A

	CALL	FILETAILREAD

	LD	A,06H
	LD	(REG_CMTWR),A
	LD	A,04H
	LD	(REG_CMTWR),A

	LD	L,(IY+FIFO_CL+0)
	LD	H,(IY+FIFO_CL+1)

	LD	A,L
	OR	H
	JR	NZ,CWWL0

		;
		; file length = 0
		;
	CALL	GET_NEWCL

	LD	(IY+FIFO_CL+0),L
	LD	(IY+FIFO_CL+1),H
	LD	(IY+FIFO_STCL+0),L
	LD	(IY+FIFO_STCL+1),H

	LD	DE,0FFFFH
	CALL	FATWRITE

	JR	CWWL1

CWWL0:
	LD	DE,0FFF8H
	OR	A
	SBC	HL,DE
	JR	C,CWWL1

		;
		; file length % (200H x FATSEC) = 0
		;
	CALL	GET_NEWCL

	LD	(IY+FIFO_CL+0),L
	LD	(IY+FIFO_CL+1),H

	PUSH	HL
	LD	DE,0FFFFH
	CALL	FATWRITE
		;
	POP	HL
	EX	DE,HL
	LD	L,(IY+FIFO_BEFCL+0)
	LD	H,(IY+FIFO_BEFCL+1)
	CALL	FATWRITE

CWWL1:

	LD	A,0CH
	LD	(REG_BUFSEL),A

	LD	A,05H
	LD	(REG_CMTWR),A
	DEC	A
	LD	(REG_CMTWR),A

	LD	A,02H
	LD	(WRITEFLAG),A


	RET


		;
		; WRITEFLAG = 2
		;
CWW_FL2:
	LD	A,01H
	LD	(REG_BUFAD),A
	LD	IY,REG_FIFO_1

	LD	A,(REG_CMTOPEN)
	AND	02H
	JR	Z,CWWL2

	LD	A,(REG_CMTWR)
	AND	10H

		;
		; saveopen = 1 and wrfull = 0
		; no process
		;
	RET	Z

		;
		; saveopen = 1 and wrfull = 1
		;

		;
		; write 1 sector
		;
	LD	L,(IY+FIFO_CL+0)
	LD	H,(IY+FIFO_CL+1)
	LD	A,(IY+FIFO_SEC)
	CALL	CALCSDADD
		;
	LD	HL,WORK
	CALL	LD4B_REG_SDADD_MHL
		;
	CALL	WRITE1SEC

		;
		; new sector
		;
	LD	L,(IY+FIFO_CL+0)
	LD	H,(IY+FIFO_CL+1)
	LD	A,(IY+FIFO_SEC)
	PUSH	HL
	CALL	GET_NEWSEC
	LD	(IY+FIFO_CL+0),L
	LD	(IY+FIFO_CL+1),H
	LD	(IY+FIFO_SEC),A

	POP	HL
	OR	A
	JR	NZ,CWWL11
		;

	LD	(IY+FIFO_BEFCL+0),L
	LD	(IY+FIFO_BEFCL+1),H
		;
	LD	L,(IY+FIFO_CL+0)
	LD	H,(IY+FIFO_CL+1)
	LD	DE,0FFFFH
	CALL	FATWRITE
		;
	LD	E,(IY+FIFO_CL+0)
	LD	D,(IY+FIFO_CL+1)
	LD	L,(IY+FIFO_BEFCL+0)
	LD	H,(IY+FIFO_BEFCL+1)

	CALL	FATWRITE

CWWL11:
	LD	A,0CH
	LD	(REG_BUFSEL),A

	LD	A,05H
	LD	(REG_CMTWR),A
	DEC	A
	LD	(REG_CMTWR),A

	RET

CWWL2:
	LD	A,(REG_CMTWR)
	AND	10H
	JR	NZ,CWWL3

		;
		; saveopen = 0 and wrfull = 0
		;

	LD	A,(IY+FIFO_WRADD+1)
	AND	01H
	OR	(IY+FIFO_WRADD+0)

		;
		; cmtwradd(8:0) <> 0
		;
	JR	NZ,CWWL3

	LD	A,(IY+FIFO_SEC)
	OR	A

		;
		; (IY+FIFO_SEC) <> 0
		;
	JR	NZ,CWWL4

		;
		; (IY+FIFO_SEC) = 0
		;

		; FAT rewind

	CALL	SDADDINIT

	LD	L,(IY+FIFO_CL+0)
	LD	H,(IY+FIFO_CL+1)
	LD	DE,0000H

	CALL	FATWRITE

	LD	L,(IY+FIFO_BEFCL+0)
	LD	H,(IY+FIFO_BEFCL+1)
	LD	A,L
	OR	H

	JR	Z,CWWL4

	LD	DE,0FFFFH
	CALL	FATWRITE

	JR	CWWL4


CWWL3:
		;
		; saveopen = 0 and wrfull = 1
		;

		;
		; write 1 sector
		;
	LD	L,(IY+FIFO_CL+0)
	LD	H,(IY+FIFO_CL+1)
	LD	A,(IY+FIFO_SEC)
	CALL	CALCSDADD
		;
	LD	HL,WORK
	CALL	LD4B_REG_SDADD_MHL
		;

	CALL	WRITE1SEC

CWWL4:
		;
		; file length and claster overwrite
		;
	XOR	A
	OR	(IY+FIFO_WRADD+0)
	OR	(IY+FIFO_WRADD+1)
	OR	(IY+FIFO_WRADD+2)
	OR	(IY+FIFO_WRADD+3)
	JR	NZ,CWWL5

		;
		; file length = 0 -> claster = 0
		;
	XOR	A
	LD	(IY+FIFO_STCL+0),A
	LD	(IY+FIFO_STCL+1),A

CWWL5:
	LD	L,(IY+FIFO_DIRCL+0)
	LD	H,(IY+FIFO_DIRCL+1)
	LD	(DIRCL),HL
	LD	L,(IY+FIFO_DIRPOS+0)
	LD	H,(IY+FIFO_DIRPOS+1)
	LD	(DIRPOS),HL

	CALL	READ_DIRFILE

	LD	A,09H
	LD	(REG_BUFSEL),A

	LD	DE,001AH
	ADD	HL,DE
		;
	LD	A,(IY+FIFO_STCL+0)
	LD	(HL),A
	INC	HL
	LD	A,(IY+FIFO_STCL+1)
	LD	(HL),A
	INC	HL
		;
	LD	A,(IY+FIFO_WRADD+0)
	LD	(HL),A
	INC	HL
	LD	A,(IY+FIFO_WRADD+1)
	LD	(HL),A
	INC	HL
	LD	A,(IY+FIFO_WRADD+2)
	LD	(HL),A
	INC	HL
	LD	A,(IY+FIFO_WRADD+3)
	LD	(HL),A

	CALL	WRITE1SEC

	XOR	A
	LD	(REG_SDCTRL),A
	INC	A
	LD	(REG_BUFSEL),A
	LD	(WRITEFLAG),A
	RET


;
; file read from any position within 512 bytes
; (REG_BUFAD) <= use FIFO number
; (IY+FIFO_CMTLEN) <= file length
; (IY+FIFO_CMTPTR) <= read start position
; (P6TBUFFER) <= key data buffer
; IY <= use FIFO number
; A  <= read length
;
; RETURN
; A <= read length
;
FILEPOSREAD:
		;
		; HLDE <= (IY+CMTLEN) - (IY+CMTPTR)
		;
	OR	A
	LD	L,(IY+FIFO_CMTLEN+0)
	LD	H,(IY+FIFO_CMTLEN+1)
	LD	C,(IY+FIFO_CMTPTR+0)
	LD	B,(IY+FIFO_CMTPTR+1)
	SBC	HL,BC
	EX	DE,HL
	LD	L,(IY+FIFO_CMTLEN+2)
	LD	H,(IY+FIFO_CMTLEN+3)
	LD	C,(IY+FIFO_CMTPTR+2)
	LD	B,(IY+FIFO_CMTPTR+3)
	SBC	HL,BC

	JR	NC,FPOSL_OK

	LD	B,00H
	PUSH	BC
	JR	FPOSL_ED

FPOSL_OK:
	PUSH	AF
	XOR	A
	OR	H
	OR	L
	OR	D
	POP	BC
	JR	NZ,FPOSL0

	LD	A,E
	CP	B
	JR	NC,FPOSL0

	LD	B,E

	LD	A,B
	OR	A
	JR	NZ,FPOSL0

	PUSH	BC
	JR	FPOSL_ED

FPOSL0:
	LD	A,01H
	LD	(REG_SDCTRL),A

	PUSH	BC
	PUSH	BC

	CALL	FILETAILREAD

	LD	L,(IY+FIFO_CMTPTR+0)
	LD	A,(IY+FIFO_CMTPTR+1)
	AND	01H
	LD	H,A
	LD	DE,REG_SDBUF
	ADD	HL,DE
		;
	LD	DE,P6TBUFFER
		;
	LD	A,01H
	LD	(IY+FIFO_FATNEW),A

	POP	BC
FPOSL1:
	PUSH	BC
	LD	A,H
	AND	01H
	OR	L
	JR	NZ,FPOSL2

	PUSH	DE

	LD	A,(IY+FIFO_FATNEW)
	OR	A
	LD	L,(IY+FIFO_CL+0)
	LD	H,(IY+FIFO_CL+1)
	LD	A,(IY+FIFO_SEC)
	CALL	Z,GET_NEXTSEC
		;

	CALL	CALCSDADD
		;
	LD	HL,WORK
	CALL	LD4B_REG_SDADD_MHL
	CALL	READ1SEC

	POP	DE
	LD	HL,REG_SDBUF

FPOSL2:
	XOR	A
	LD	(IY+FIFO_FATNEW),A
		;
	LD	A,(HL)
	LD	(DE),A
		;
	INC	HL
	INC	DE

	POP	BC
	DJNZ	FPOSL1

FPOSL_ED:
	XOR	A
	LD	(REG_SDCTRL),A
	LD	(IY+FIFO_SEC),A

	LD	A,(IY+FIFO_STCL+0)
	LD	(IY+FIFO_CL+0),A
	LD	A,(IY+FIFO_STCL+1)
	LD	(IY+FIFO_CL+1),A

	LD	HL,REG_CMTRD
	LD	(HL),02H
	LD	(HL),00H

	POP	AF
	RET


;
; 1 sector read from file tail
; (REG_BUFAD) <= use FIFO number
; (IY+FIFO_CMTPTR) <= read length
; IY <= use FIFO number
;
; RETURN :
; (IY+CL),(IY+SEC) <= next sector
; (IY+BEFCL)       <= before claster
;
; Zflag <= 1  -> not read 1 sector
; 
; (IY+CL),(IY+BEFCL) = 0000H
; -> file length = 0  (and not read 1 sector)
;
; (IY+CL) >= FFF8H
; -> file length % 200H = 0  (and not read 1 sector)
;

FILETAILREAD:
	LD	A,(IY+FIFO_STCL+0)
	LD	(IY+FIFO_CL+0),A
	LD	A,(IY+FIFO_STCL+1)
	LD	(IY+FIFO_CL+1),A
	XOR	A
	LD	(IY+FIFO_SEC),A
	LD	(IY+FIFO_BEFCL+0),A
	LD	(IY+FIFO_BEFCL+1),A
	LD	HL,0000H
	LD	(WORK4+0),HL
	LD	(WORK4+2),HL

FDRL2:
		;
		; CP (IY+FIFO_CMTPTR)-(WORK4)
		;
	PUSH	IY
	POP	HL
	LD	E,FIFO_CMTPTR
	LD	D,00H
	ADD	HL,DE
	PUSH	HL
		;
	LD	DE,WORK4
	LD	B,04H
	CALL	CP_MHL_MDE
	POP	HL

	RET	Z

	PUSH	HL

		;
		; (WORK4) = (WORK4) + 0200H
		;
	LD	HL,0200H
	LD	(WORK+0),HL
	LD	HL,0000H
	LD	(WORK+2),HL
	LD	DE,WORK
	LD	HL,WORK4
	CALL	ADD4B_MHL_MDE

		;
		; CP (IY+FIFO_CMTPTR)-(WORK4)
		;
	POP	HL
	LD	DE,WORK4
	LD	B,04H
	CALL	CP_MHL_MDE
	JR	C,FDRL_END

		;
		; sector ++
		;
	LD	L,(IY+FIFO_CL+0)
	LD	H,(IY+FIFO_CL+1)
	LD	A,(IY+FIFO_SEC)
	PUSH	HL
	CALL	GET_NEXTSEC
	LD	(IY+FIFO_CL+0),L
	LD	(IY+FIFO_CL+1),H
	LD	(IY+FIFO_SEC),A
		;
	POP	HL
	OR	A
	JR	NZ,FDRL2
		;
	LD	(IY+FIFO_BEFCL+0),L
	LD	(IY+FIFO_BEFCL+1),H
		;
	JR	FDRL2


FDRL_END:
		;
		; read 1 sector of file end
		;
	LD	L,(IY+FIFO_CL+0)
	LD	H,(IY+FIFO_CL+1)
	LD	A,H
	OR	L
	JP	Z,SDERR
	LD	A,(IY+FIFO_SEC)
	CALL	CALCSDADD
		;
	LD	HL,WORK
	CALL	LD4B_REG_SDADD_MHL
		;
	CALL	READ1SEC
		;
	LD	A,01H
	OR	A
	RET


;
; jump read pointer
; (REG_BUFAD) <= use FIFO number
; BCDE <= read pointer
; IY <= use FIFO number
;
JMPREADPTR:
	LD	(IY+FIFO_CMTPTR+0),E
	LD	(IY+FIFO_CMTPTR+1),D
	LD	(IY+FIFO_CMTPTR+2),C
	LD	(IY+FIFO_CMTPTR+3),B
	CALL	FILETAILREAD
	RET	NZ
	JR	FDRL_END

;
; rewind read pointer
; (REG_BUFAD) <= use FIFO number
; read(write) pointer <= sector address
; BCDE <= pointer added
; IY <= use FIFO number
;
MOVEREADPTR:
	LD	HL,WORK
	LD	(HL),E
	INC	HL
	LD	(HL),D
	INC	HL
	LD	(HL),C
	INC	HL
	LD	(HL),B

	PUSH	IY
	POP	HL
	LD	C,FIFO_CMTPTR
	LD	B,00H
	ADD	HL,BC
	LD	DE,WORK
	CALL	ADD4B_MHL_MDE

	CALL	FILETAILREAD
	RET	NZ
	JR	FDRL_END

;
; 1 byte read from file
; (REG_BUFAD) <= use FIFO number
; (IY+FIFO_CMTPTR) <= read pointer
; IY <= use FIFO number
;
; RETURN :
; A <= read data
; (IY+FIFO_CMTPTR) <= read pointer + 1
;
;
READ1BYTE:
	PUSH	BC
	PUSH	DE
	PUSH	HL

		;
		; 1 byte read
		;
	LD	E,(IY+FIFO_CMTPTR+0)
	LD	A,(IY+FIFO_CMTPTR+1)
	AND	01H
	LD	D,A
	LD	HL,REG_SDBUF
	ADD	HL,DE

	LD	A,01H
	LD	(REG_BUFSEL),A
	LD	A,(HL)
	PUSH	AF

		;
		; INC (IY+FIFO_CMTPTR)
		;
	PUSH	IY
	POP	HL
	LD	E,FIFO_CMTPTR
	LD	D,00H
	ADD	HL,DE
		;
	LD	A,01H
	CALL	ADD4B_MHL_A

		;
		; (IY+FIFO_CMTPTR) % 200H = 0?
		;
	LD	E,(IY+FIFO_CMTPTR+0)
	LD	A,(IY+FIFO_CMTPTR+1)
	AND	01H
	OR	E
	JR	NZ,LR1BL1

		;
		; sector ++
		;
	LD	L,(IY+FIFO_CL+0)
	LD	H,(IY+FIFO_CL+1)
	LD	A,(IY+FIFO_SEC)
	PUSH	HL
	CALL	GET_NEXTSEC
	LD	(IY+FIFO_CL+0),L
	LD	(IY+FIFO_CL+1),H
	LD	(IY+FIFO_SEC),A
		;
	POP	HL
	OR	A
	JR	NZ,LR1BL2
		;
	LD	(IY+FIFO_BEFCL+0),L
	LD	(IY+FIFO_BEFCL+1),H
		;

		;
		; 1 sector read
		;
LR1BL2:
	LD	L,(IY+FIFO_CL+0)
	LD	H,(IY+FIFO_CL+1)
	LD	A,L
	OR	H
	JP	Z,SDERR
	LD	A,(IY+FIFO_SEC)
	CALL	CALCSDADD
		;
	LD	HL,WORK
	CALL	LD4B_REG_SDADD_MHL
		;
	CALL	READ1SEC
		;

LR1BL1:
	POP	AF
	POP	HL
	POP	DE
	POP	BC
	RET

;
; 1 byte write to file
; (REG_BUFAD) <= use FIFO number
; (IY+FIFO_CMTPTR) <= read(write) pointer
; IY <= use FIFO number
; A <= write data
;
; RETURN :
; (IY+FIFO_CMTPTR) <= read(write) pointer + 1
;
;
WRITE1BYTE:
	PUSH	BC
	PUSH	DE
	PUSH	HL
	PUSH	AF

		;
		; 1 byte write
		;
	LD	E,(IY+FIFO_CMTPTR+0)
	LD	A,(IY+FIFO_CMTPTR+1)
	AND	01H
	LD	D,A
	LD	HL,REG_SDBUF
	ADD	HL,DE

	LD	A,09H
	LD	(REG_BUFSEL),A
	POP	AF
	LD	(HL),A

		;
		; INC (IY+FIFO_CMTPTR)
		;
	PUSH	IY
	POP	HL
	LD	E,FIFO_CMTPTR
	LD	D,00H
	ADD	HL,DE
		;
	LD	A,01H
	CALL	ADD4B_MHL_A

		;
		; (IY+FIFO_CMTPTR) % 200H = 0?
		;
	LD	E,(IY+FIFO_CMTPTR+0)
	LD	A,(IY+FIFO_CMTPTR+1)
	AND	01H
	OR	E
	JR	NZ,LW1BL1

		;
		; 1 sector write
		;
	LD	L,(IY+FIFO_CL+0)
	LD	H,(IY+FIFO_CL+1)
	LD	A,(IY+FIFO_SEC)
	CALL	CALCSDADD
		;
	LD	HL,WORK
	CALL	LD4B_REG_SDADD_MHL
		;
	CALL	WRITE1SEC

		;
		; sector ++
		;
	LD	L,(IY+FIFO_CL+0)
	LD	H,(IY+FIFO_CL+1)
	LD	A,(IY+FIFO_SEC)
	PUSH	HL
	CALL	GET_NEXTSEC
	LD	(IY+FIFO_CL+0),L
	LD	(IY+FIFO_CL+1),H
	LD	(IY+FIFO_SEC),A
		;
	POP	HL
	OR	A
	JR	NZ,LW1BL2
		;
	LD	(IY+FIFO_BEFCL+0),L
	LD	(IY+FIFO_BEFCL+1),H
		;

		;
		; 1 sector read
		;
LW1BL2:
	LD	L,(IY+FIFO_CL+0)
	LD	H,(IY+FIFO_CL+1)
	LD	A,L
	OR	H
	JP	Z,SDERR
	LD	A,(IY+FIFO_SEC)
	CALL	CALCSDADD
		;
	LD	HL,WORK
	CALL	LD4B_REG_SDADD_MHL
		;
	CALL	READ1SEC
		;

LW1BL1:
	POP	HL
	POP	DE
	POP	BC
	RET


;
; ROM file read
; IX <= file name address
; HL <= ROM start address
; DE <= ROM start address (BANK number)
;
ROMFILEREAD:
	CALL	ROMFILEREAD2
	JP	C,SDERR
	RET

;
; ROM file read
; IX <= file name address
; HL <= ROM start address
; DE <= ROM start address (BANK number)
;
; RETURN:Cflag=1 FILE not found
ROMFILEREAD2:
	XOR	A
	LD	(REG_BUFAD),A
	LD	IY,REG_FIFO_0
	LD	A,05H
	LD	(FILESEL),A

	PUSH	IX
	PUSH	HL
	PUSH	DE

	LD	IX,F_ROMDIR
	LD	A,10H
	LD	(SEARCHTYPE),A
	LD	HL,0000H
	LD	(DIRCL),HL
	CALL	FILESEARCH
	JP	C,SDERR

	POP	DE
	POP	HL
	POP	IX

	LD	A,(IY+FIFO_CL+0)
	LD	(DIRCL+0),A
	LD	A,(IY+FIFO_CL+1)
	LD	(DIRCL+1),A

	LD	(IY+FIFO_CMTPTR+0),L
	LD	(IY+FIFO_CMTPTR+1),H
	LD	(IY+FIFO_CMTPTR+2),E
	LD	(IY+FIFO_CMTPTR+3),D
		;
	XOR	A
	LD	(SEARCHTYPE),A
	CALL	FILESEARCH
	RET	C
	CALL	FILEREAD
		;
	RET

;
; file read
; (REG_BUFAD) <= use FIFO number
; (FILESEL) <= FIFO type
; IY <= use FIFO number
;
FILEREAD:
	LD	A,01H
	LD	(REG_SDCTRL),A
	LD	A,(FILESEL)
	LD	(REG_BUFSEL),A
	LD	HL,REG_CMTRD
	LD	(HL),02H
	LD	(HL),00H
		;
FRL1:	LD	L,(IY+FIFO_CL+0)
	LD	H,(IY+FIFO_CL+1)
	LD	A,L
	OR	H
	JP	Z,SDERR
	LD	A,(IY+FIFO_SEC)
	CALL	CALCSDADD
		;
	LD	HL,WORK
	CALL	LD4B_REG_SDADD_MHL
		;

	CALL	READ1SEC
		;
READCONT:
	LD	A,01H
	LD	(REG_SDCTRL),A
	LD	A,(FILESEL)
	LD	(REG_BUFSEL),A
	LD	A,01H
	LD	(REG_CMTRD),A
		;
FRL3:	LD	A,(FILESEL)
	CP	05H
	JR	Z,FRL2
	LD	A,(REG_CMTOPEN)
	AND	01H
	JR	Z,FRL4
FRL2:	LD	A,(REG_CMTRD)
	BIT	5,A
	JR	NZ,FRL4
	BIT	4,A
	JR	Z,FRL3
		;
	XOR	A
	LD	(REG_CMTRD),A
		;
	LD	L,(IY+FIFO_CL+0)
	LD	H,(IY+FIFO_CL+1)
	LD	A,(IY+FIFO_SEC)
	CALL	GET_NEXTSEC
	LD	(IY+FIFO_CL+0),L
	LD	(IY+FIFO_CL+1),H
	LD	(IY+FIFO_SEC),A
		;
	JR	FRL1
		;
FRL4:	XOR	A
	LD	(REG_CMTRD),A
	LD	(REG_SDCTRL),A
	RET

;
; rom file seaech in root directory
; (REG_BUFAD) <= use FIFO number
; IX <= file name address
; IY <= use FIFO number
;
; RETURN
; (IY+FIFO_CMTLEN) <= file length
; (IY+FIFO_CL)     <= file claster number
; (IY+FIFO_SEC)    <= file sector number
; (IY+FIFO_STCL)   <= file start claster number
; (IY+FIFO_DIRCL)  <= file claster in directory
; (IY+FIFO_DIRPOS) <= file position in directory
; Cflag = 1           file not found
FILESEARCH:
	LD	A,01H
	LD	(REG_SDCTRL),A
	LD	HL,0000H
	LD	(DIRPOS),HL
	CALL	SDADDINIT
		;
FSL1:	CALL	READ_DIRFILE
		;
	LD	A,(HL)
	OR	A
	JR	Z,FSL3
	PUSH	IX
	POP	DE
	PUSH	HL
	LD	B,0BH
	CALL	CP_MHL_MDE
	POP	HL
	JR	NZ,FSL11
	LD	BC,000BH
	ADD	HL,BC
	LD	A,(HL)
	AND	1EH
	LD	B,A
	LD	A,(SEARCHTYPE)
	CP	B
	JR	Z,FSL2
		;
FSL11:	LD	HL,(DIRPOS)
	INC	HL
	LD	(DIRPOS),HL
	LD	A,H
	CP	02H
	JR	NC,FSL3
	JR	FSL1
		;
FSL2:	LD	BC,000FH
	ADD	HL,BC
	
	CALL	SETFILEPARA
		;
	XOR	A
	LD	(IY+FIFO_SEC),A
	LD	(REG_SDCTRL),A
	RET

FSL3:
	XOR	A
	LD	(IY+FIFO_SEC),A
	LD	(REG_SDCTRL),A
	SCF
	RET

;
; rom area initialize
;
ROMINIT:
	LD	HL,REG_ROMINIT
	LD	(HL),01H
	DEC	(HL)
ROMLP:	LD	A,(HL)
	OR	A
	JR	NZ,ROMLP
	RET

;
; SD card initialized and read parameter
; use #0 FIFO (REG_BUFAD = 00H)
;
SDCARD_OPEN:
	LD	HL,REG_SDCTRL
	LD	(HL),01H
	XOR	A
	LD	(REG_BUFAD),A
;
; command 0 (S/W reset)
;
	LD	HL,0000H
	LD	(REG_SDADD),HL
	LD	(REG_SDADD+2),HL
	XOR	A
	CALL	SENDCMD2
;
; command 1 (idle detect)
;
SDW1:	LD	A,01H
	CALL	SENDCMD2
	BIT	1,(HL)
	JR	NZ,SDW1
;
; command 16 (length set)
;
	LD	A,10H
	CALL	SENDCMD
;
; read phisical sector #0
;
	CALL	READ1SEC
	LD	HL,REG_OFFSET
	LD	DE,OFFSET
	CALL	LD4B_MDE_MHL
;
; read logical sector #0 (read BPB parameter)
;
	LD	HL,OFFSET
	CALL	LD4B_REG_SDADD_MHL
	CALL	READ1SEC
	CALL	CHKSPT
		;
		; claster size = BPB_CLASTSEC
		;
	LD	A,(BPB_CLASTSEC)
	LD	(CLASTSIZE),A
		;
		; FAT start = OFFSET + BPB_FATST
		;
	LD	HL,(OFFSET)
	LD	DE,(BPB_FATST)
	ADD	HL,DE
	LD	(FATST),HL
	LD	HL,(OFFSET+2)
	LD	DE,0000H
	ADC	HL,DE
	LD	(FATST+2),HL
;		;
;		; root directory start = FATST + BPB_FATNUM x BPB_FATSEC
;		;
;	LD	DE,ROOTST
;	LD	HL,FATST
;	CALL	LD4B_MDE_MHL
;	LD	HL,(BPB_FATSEC)
;	LD	(WORK),HL
;	LD	HL,0000H
;	LD	(WORK+2),HL
;
;	LD	A,(BPB_FATNUM)
;	LD	B,08H
;RDLP1:	RRCA
;	PUSH	AF
;	PUSH	BC
;	JR	NC,RDLP2
;	LD	HL,ROOTST
;	LD	DE,WORK
;	CALL	ADD4B_MHL_MDE
;		;
;RDLP2:	LD	HL,WORK
;	CALL	SHT4B_MHL
;		;
;	POP	BC
;	POP	AF
;	DJNZ	RDLP1
		;
		; FAT use sector number = BPB_FATSEC
		;
	LD	HL,(BPB_FATSEC)
	LD	(FATSEC),HL
		;
		; root directory start = FATST + BPB_FATNUM(=02H) x FATSEC
		;
	LD	DE,ROOTST
	LD	HL,FATST
	CALL	LD4B_MDE_MHL
	LD	HL,(FATSEC)
	LD	(WORK),HL
	LD	HL,0000H
	LD	(WORK+2),HL
	LD	HL,WORK
	CALL	SHT4B_MHL
	LD	HL,ROOTST
	LD	DE,WORK
	CALL	ADD4B_MHL_MDE
		;
		; claster start = ROOTST + 32
		;
	LD	HL,ROOTST
	LD	DE,CLASTST
	CALL	LD4B_MDE_MHL
	LD	HL,CLASTST
	LD	A,20H
	CALL	ADD4B_MHL_A
		;
	XOR	A
	LD	(REG_SDCTRL),A
		;
	RET



;
; directory file list read
; (REG_BUFAD) <= use FIFO number
; (DIRCL)     <= claster number of directory claster (0000H = root)
; (DIRPOS)    <= file position in directory
;
; RETURN
; HL:file pointer address
;
READ_DIRFILE:
	LD	HL,(DIRPOS)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	B,H
	LD	HL,(DIRCL)
	LD	A,H
	OR	L
	JR	NZ,RDL1
		;
		; root directory
		;
	LD	HL,ROOTST
	PUSH	BC
	CALL	LD4B_WORK_MHL
	POP	BC
	LD	A,B
	LD	HL,WORK
	CALL	ADD4B_MHL_A
	JR	RDL2
		;
		;
RDL1:	XOR	A
	INC	B
		;
RDL3:	DEC	B
	JR	Z,RDL4
	PUSH	BC
	CALL	GET_NEXTSEC
	POP	BC
	JR	RDL3
		;
RDL4:	CALL	CALCSDADD
		;
RDL2:	LD	HL,WORK
	LD	DE,REG_SDADD
	LD	B,04H
	CALL	CP_MHL_MDE
	JR	Z,RDL5
		;
	LD	HL,WORK
	CALL	LD4B_REG_SDADD_MHL
	CALL	READ1SEC
		;
RDL5:	LD	A,(DIRPOS)
	AND	0FH
	LD	L,A
	LD	H,00H
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,REG_SDBUF
	ADD	HL,DE
	RET


;
; claster and sector number -> SD address
;
; SD address <= CLASTST + CLASTSIZE x (claster - 2) + sector
; (REG_BUFAD) <= use FIFO number
; HL : claster number
; A  : sector number
;
; RETURN : (WORK) <- SD address
;
CALCSDADD:
	CALL	CLASTCHECK
	DEC	HL
	DEC	HL
	LD	(WORK2),HL
	LD	HL,0000H
	LD	(WORK2+2),HL
		;
	LD	HL,CLASTST
	CALL	LD4B_WORK_MHL
	LD	HL,WORK
	CALL	ADD4B_MHL_A
		;	
	LD	A,(CLASTSIZE)
	LD	B,08H
CSAL2:	RRCA
	PUSH	AF
	PUSH	BC
	JR	NC,CSAL1
	LD	HL,WORK
	LD	DE,WORK2
	CALL	ADD4B_MHL_MDE
		;
CSAL1:	LD	HL,WORK2
	CALL	SHT4B_MHL
		;
	POP	BC
	POP	AF
	DJNZ	CSAL2
		;
	RET


;
; get next sector
; (REG_BUFAD) <= use FIFO number
; HL : claster number
; A  : sector number
;
; RETURN
; HL <= next claster number
; A  <= next sector number
;
GET_NEXTSEC:
	CALL	CLASTCHECK
	LD	C,A
	INC	C
	LD	A,(CLASTSIZE)
	LD	B,A
	LD	A,C
	CP	B
	RET	C
		;
	CALL	GET_NEXTCL
	XOR	A
	RET

;
; get next claster number from FAT
; (REG_BUFAD) <= use FIFO number
; HL : claster number
;
; RETURN : HL <= next claster number
;
GET_NEXTCL:
	CALL	CLASTCHECK

	PUSH	HL
	CALL	SDADDINIT
	POP	HL
	XOR	A
	CALL	CALCFATADD	

	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	RET

;
; claster number check
; HL : claster number
;
CLASTCHECK:
	PUSH	HL
	PUSH	DE
	LD	DE,0FFF7H
	OR	A
	SBC	HL,DE
	JP	NC,SDERR
	POP	DE
	POP	HL
	RET

;
; get new sector
; (REG_BUFAD) <= use FIFO number
; HL : claster number
; A  : sector number
;
; RETURN
; HL <= next claster number
; A  <= next sector number
;
GET_NEWSEC:
	CALL	CLASTCHECK
	LD	C,A
	INC	C
	LD	A,(CLASTSIZE)
	LD	B,A
	LD	A,C
	CP	B
	RET	C
		;
	CALL	GET_NEWCL
	XOR	A
	RET

;
; get new claster number from FAT
; (REG_BUFAD) <= use FIFO number
;
; RETURN : HL <= next claster number
;
GET_NEWCL:
	CALL	SDADDINIT
	LD	HL,0000H

GNCL_LP:
	PUSH	HL

	XOR	A
	CALL	CALCFATADD
		;
	LD	E,(HL)
	INC	HL
	LD	A,(HL)
	OR	E
	POP	HL

	JR	NZ,GNCL_NG

	PUSH	HL

	LD	A,01H
	CALL	CALCFATADD
		;
	LD	E,(HL)
	INC	HL
	LD	A,(HL)
	OR	E
	POP	HL

	RET	Z

GNCL_NG:
	INC	HL
	EX	DE,HL

	LD	HL,(FATSEC)
	LD	H,L
	LD	L,00H
	ADD	HL,HL

	OR	A
	SBC	HL,DE
	EX	DE,HL

	JP	NC,GNCL_LP

	JP	SDERR


;
; FAT overwrite
; (REG_BUFAD) <= use FIFO number
; HL <= claster number
; DE <= new data
;
FATWRITE:
	CALL	CLASTCHECK

	PUSH	DE
	PUSH	HL
	PUSH	DE
	PUSH	HL

	CALL	SDADDINIT
	POP	HL
	XOR	A
	CALL	CALCFATADD
		;

	LD	A,09H
	LD	(REG_BUFSEL),A
		;
	POP	DE
	LD	(HL),E
	INC	HL
	LD	(HL),D
		;
	LD	A,01H
	LD	(REG_BUFSEL),A
		;

	CALL	WRITE1SEC

	POP	HL
		;
	LD	A,01H
	CALL	CALCFATADD
		;
	LD	A,09H
	LD	(REG_BUFSEL),A
		;
	POP	DE
	LD	(HL),E
	INC	HL
	LD	(HL),D
		;
	LD	A,01H
	LD	(REG_BUFSEL),A
		;

	CALL	WRITE1SEC


	RET

;
; FAT address calculate
; (REG_BUFAD) <= use FIFO number
; HL <= claster number
; A  <= 1:FAT#2 0:FAT#1
;
; RETURN
; HL <= FAT address
;
CALCFATADD:
	PUSH	HL
	PUSH	AF
	PUSH	HL

	LD	DE,WORK3
	LD	HL,REG_SDADD
	CALL	LD4B_MDE_MHL

		;
		; SDADD <= FATST + claster number / 16 (+ FATSEC)
		;
	LD	HL,FATST
	CALL	LD4B_REG_SDADD_MHL
	POP	HL
	LD	A,H
	LD	HL,REG_SDADD
	CALL	ADD4B_MHL_A
	POP	AF
	OR	A
	JR	Z,CFAL1
		;
	LD	HL,(FATSEC)
	LD	(WORK+0),HL
	LD	HL,0000H
	LD	(WORK+2),HL
	LD	DE,WORK
	LD	HL,REG_SDADD
	CALL	ADD4B_MHL_MDE
CFAL1:
		;
	LD	HL,WORK3
	LD	DE,REG_SDADD
	LD	B,04H
	CALL	CP_MHL_MDE
		;
	CALL	NZ,READ1SEC
		;
	POP	HL
	LD	H,00H
	ADD	HL,HL
	LD	DE,REG_SDBUF
	ADD	HL,DE

	RET

;
; (HL)x4b <- (HL)x4b + (DE)x4b
;
ADD4B_MHL_MDE:
	LD	A,(DE)
	ADD	A,(HL)
	LD	(HL),A
	INC	DE
	INC	HL
	LD	A,(DE)
	ADC	A,(HL)
	LD	(HL),A
	INC	DE
	INC	HL
	LD	A,(DE)
	ADC	A,(HL)
	LD	(HL),A
	INC	DE
	INC	HL
	LD	A,(DE)
	ADC	A,(HL)
	LD	(HL),A
	RET


;
; (HL)x4b <- (HL)x4b + A
;
ADD4B_MHL_A:
	ADD	A,(HL)
	LD	(HL),A
	INC	HL
	LD	A,00H
	ADC	A,(HL)
	LD	(HL),A
	INC	HL
	LD	A,00H
	ADC	A,(HL)
	LD	(HL),A
	INC	HL
	LD	A,00H
	ADC	A,(HL)
	LD	(HL),A
	RET


;
; (HL)x4b <- (HL)x4b x 2
;
SHT4B_MHL:
	OR	A
	LD	A,(HL)
	RLA
	LD	(HL),A
	INC	HL
	LD	A,(HL)
	RLA
	LD	(HL),A
	INC	HL
	LD	A,(HL)
	RLA
	LD	(HL),A
	INC	HL
	LD	A,(HL)
	RLA
	LD	(HL),A
	RET


;
; CP (HL)-(DE) x B byte
;
; RETURN
; (HL) > (DE) : Cflag reset / Zflag reset
; (HL) = (DE) : Cflag reset / Zflag set
; (HL) < (DE) : Cflag set   / Zflag reset
;
CP_MHL_MDE:
	LD	A,B
CPL1:	INC	DE
	INC	HL
	DJNZ	CPL1
	LD	B,A

CPL2:	DEC	DE
	DEC	HL
	LD	A,(DE)
	CP	(HL)
	CCF
	RET	NZ
	DJNZ	CPL2
	XOR	A
	RET

;
; (DE)x4b <- (HL)x4b
;
LD4B_MDE_MHL:
	LD	BC,0004H
	LDIR
	RET

;
; (REG_SDADD)x4b <- (HL)x4b
;
LD4B_REG_SDADD_MHL:
	LD	DE,REG_SDADD
	LD	BC,0004H
	LDIR
	RET

;
; (WORK)x4b <- (HL)x4b
;
LD4B_WORK_MHL:
	LD	DE,WORK
	LD	BC,0004H
	LDIR
	RET


;
; read 1 sector
;
READ1SEC:
	LD	A,08H
	LD	(REG_BUFSEL),A
	LD	HL,REG_SDRD
	LD	(HL),01H
	DEC	(HL)
	LD	A,11H
	CALL	SENDCMD
RSL1:	LD	A,(REG_SDRD)
	AND	10H
	JR	Z,RSL1
	LD	A,01H
	LD	(REG_BUFSEL),A
	RET

;
; write 1 sector
;

WRITE1SEC:
	XOR	A
	LD	(REG_BUFSEL),A
	LD	HL,REG_SDWR
	LD	(HL),01H
	DEC	(HL)
	LD	A,18H
	CALL	SENDCMD
WSL1:	LD	A,(REG_SDWR)
	AND	10H
	JR	Z,WSL1

	LD	A,01H
	LD	(REG_BUFSEL),A
	RET



SENDCMD:
;
; Areg <= command_No
;
	LD	(REG_SDCMDNO),A
	LD	HL,REG_SDCMDST
	LD	(HL),01H
	DEC	(HL)
SCL1:	BIT	0,(HL)
	JR	NZ,SCL1
	LD	A,06H
	AND	(HL)
	JR	NZ,SDERR
	RET


SENDCMD2:
;
; Areg <= command_No
;
	LD	(REG_SDCMDNO),A
	LD	HL,REG_SDCMDST
	LD	(HL),01H
	DEC	(HL)
SCL2:	BIT	0,(HL)
	JR	NZ,SCL2
	BIT	2,(HL)
	JR	NZ,SDERR
	RET


CHKSPT:
;
; SD card support check
;
; FAT16
; # of FAT = 02H
; # of sector byte = 0200H
; # of root directory entry = 0200H

	LD	HL,(BPB_FATVER)
	LD	DE,3631H
	OR	A
	SBC	HL,DE
	JR	NZ,SDERR
		;
	LD	A,(BPB_FATNUM)
	CP	02H
	JR	NZ,SDERR
		;
	LD	HL,(BPB_SECBYTE)
	LD	DE,0200H
	OR	A
	SBC	HL,DE
	JR	NZ,SDERR
		;
	LD	HL,(BPB_DIRENTRY)
	OR	A
	SBC	HL,DE
	JR	NZ,SDERR
	RET


SDERR:
;
; SD card error
;
	LD	HL,REG_SDCTRL
	LD	A,02H
	LD	(HL),A
	LD	SP,INITSP
	LD	A,(SDMODE)
	OR	A
ERRLP:	JR	Z,ERRLP
	CP	01H
	JP	Z,MAINSTART
	JP	MAINST2
	JR	ERRLP

;
; LCD initialize
;
LCD_INIT:
	LD	DE,00300H
	CALL	LCD_OUTDT
	LD	DE,00001H
	CALL	LCD_OUTDT
	LD	DE,00002H
	CALL	LCD_OUTDT
	LD	DE,0CC03H
	CALL	LCD_OUTDT
	LD	DE,04604H
	CALL	LCD_OUTDT
	LD	DE,00D05H
	CALL	LCD_OUTDT
	LD	DE,00007H
	CALL	LCD_OUTDT

	LD	A,01H
	LD	(REG_LCDDONE),A

	RET

;
; LCD setting data output
;
LCD_OUTDT:
	LD	HL,REG_LCDST
	LD	(REG_LCDADD),DE
	LD	(HL),01H
	XOR	A
LCDD1:	CP	(HL)
	JR	NZ,LCDD1
	RET

;
; FDD initialize
;
FDUNITINIT:
	XOR	A
	LD	(REG_FDD0),A
	LD	(REG_FDD1),A
	LD	(REG_FDD2),A
	LD	(REG_FDD3),A
	LD	(EXTFDDST),A
	LD	(REG_EXTFDDCIO),A
	LD	(EXTFDDRLEN),A
	LD	(EXTFDDSLEN),A
	RET

;
; UART initialize
;
UARTINIT:
	XOR	A
	LD	(REG_UARTENB),A
	LD	(UART_BAUD),A
	RET

;
; SD registers and circuits initialize
;
SDREGINIT:
	CALL	SDREGINIT_0
	CALL	SDREGINIT_1
	LD	IY,REG_FIFO_2
	CALL	SDREGINIT_2
	LD	IY,REG_FIFO_3
	CALL	SDREGINIT_2
	LD	IY,REG_FIFO_4
	CALL	SDREGINIT_2
	LD	IY,REG_FIFO_5
	CALL	SDREGINIT_2
		;
	LD	HL,REG_SDRD
	LD	(HL),01H
	LD	(HL),00H
		;
	LD	A,(REG_SDWP)
	LD	(SDWPFLAG),A
		;
	LD	HL,0000H
	LD	(SDDETTIMER),HL
		;
	LD	DE,ST_CMTREAD_VAL
	CALL	LD_ST_NOSELECT
	LD	DE,ST_CMTWRITE_VAL
	CALL	LD_ST_NOSELECT
	LD	DE,ST_FDD0INTFILE_VAL
	CALL	LD_ST_NOSELECT
	LD	DE,ST_FDD1INTFILE_VAL
	CALL	LD_ST_NOSELECT
	LD	DE,ST_FDD0EXTFILE_VAL
	CALL	LD_ST_NOSELECT
	LD	DE,ST_FDD1EXTFILE_VAL
	CALL	LD_ST_NOSELECT
		;
	LD	A,(REG_SDWP)
	OR	A
	RET	Z
		;
	LD	DE,ST_CMTWRITE_VAL
	LD	HL,ST_WRPROTECT
	LD	BC,000CH
	LDIR
		;
	RET

;
; SD registers and circuits initialize (#0:CMT load FIFO)
;
SDREGINIT_0:
	PUSH	HL
	LD	HL,REG_FIFO_0
	XOR	A
	LD	B,20H
SRL1_0:	LD	(HL),A
	INC	HL
	DJNZ	SRL1_0
		;
	LD	IY,REG_FIFO_0
		;
	LD	HL,REG_CMTRD
	LD	(HL),02H
	LD	(HL),00H
		;
	XOR	A
	LD	(READFLAG),A
	LD	(P6TCMDENB),A
	LD	(P6TCMDENBBEF),A
	LD	(P6TFILEREAD),A
		;
	POP	HL
	RET

;
; SD registers and circuits initialize (#1:CMT save FIFO)
;
SDREGINIT_1:
	PUSH	HL
	LD	HL,REG_FIFO_1
	XOR	A
	LD	B,20H
SRL1_1:	LD	(HL),A
	INC	HL
	DJNZ	SRL1_1
		;
	LD	IY,REG_FIFO_1
		;
	XOR	A
	LD	(REG_CMTWR),A
	LD	(WRITEFLAG),A
		;
	POP	HL
	RET

;
; SD registers and circuits initialize (#2:INT FDD#0 FIFO)
;
SDREGINIT_2:
	PUSH	HL

	PUSH	IY
	POP	HL
	XOR	A
	LD	B,1EH
SRL1_2:	LD	(HL),A
	INC	HL
	DJNZ	SRL1_2
		;
	XOR	A
	LD	(IY+FIFO_FLOPPY),A
		;
	POP	HL
	RET


;
; copy "no select" string
;
LD_ST_NOSELECT:
	LD	HL,ST_NOSELECT
	LD	BC,000CH
	LDIR
	RET

;
; SD address initialize
;
SDADDINIT:
	LD	HL,0FFFFH
	LD	(REG_SDADD),HL
	LD	(REG_SDADD+2),HL
	RET

;
; function key buffer initialize
;
KEYBUFINIT:
	LD	HL,CTRLNOW
	XOR	A
	LD	B,0CH
KBL1:	LD	(HL),A
	INC	HL
	DJNZ	KBL1
	RET

;
; detect SD card insert or eject
;
DETSDEJECT:
	LD	A,(REG_SDWP)
	LD	B,A
	LD	A,(SDWPFLAG)
	XOR	B
	JR	Z,DSEL1

		;
		; detected SD card insert / eject
		;
	LD	A,(REG_SDWP)
	LD	(SDWPFLAG),A
		;
	LD	HL,1000H
	LD	(SDDETTIMER),HL
	RET

DSEL1:
	LD	HL,(SDDETTIMER)
	LD	A,H
	OR	L
	RET	Z

	DEC	HL
	LD	(SDDETTIMER),HL
	LD	A,H
	OR	L
	RET	NZ

		;
		; timer full
		;
	CALL	SDCARD_OPEN
	CALL	SDREGINIT

	LD	A,01H
	LD	(PAGEREDRAW),A
		;

	RET


;
; p6t format auto command input
;
P6TKEYWAIT:
	LD	A,(P6TCMDENBBEF)
	LD	C,A
	LD	A,(P6TCMDENB)
	LD	B,A
	LD	(P6TCMDENBBEF),A

	LD	A,(P6TFILEREAD)
	OR	A
	RET	Z

	LD	A,B
	OR	A
	LD	A,C
	JR	NZ,P6L1

	OR	A
	RET	Z

		;
		; auto mode -> manual mode
		;
	LD	HL,0000H
	LD	(KEYTIMER),HL

	LD	A,(READFLAG)
	OR	A
	RET	Z

	LD	HL,(REG_FIFO_0+FIFO_STCL)
	LD	(REG_FIFO_0+FIFO_CL),HL
	XOR	A
	LD	(REG_FIFO_0+FIFO_SEC),A
	INC	A
	LD	(READFLAG),A

	LD	HL,REG_CMTRD
	LD	(HL),02H
	LD	(HL),00H

	RET

P6L1:
	OR	A
	JR	NZ,P6L2

		;
		; manual mode -> auto mode
		;

	LD	HL,1000H
	LD	(KEYTIMER),HL
	XOR	A
	LD	(P6TKEYPUSH),A
	LD	A,05H
	LD	(P6TBUFPOS),A

	RET

P6L2:		;
		; auto mode
		;
		; judge command finish
		;
	LD	A,(P6TCMDLEN)
	LD	B,A
	LD	A,(P6TBUFPOS)
	CP	B
	RET	NC

		;
		; judge timer full and CMT read end
		;
	LD	HL,(KEYTIMER)
	LD	A,H
	OR	L
	JR	Z,P6LPUSH

	DEC	HL
	LD	(KEYTIMER),HL
	RET

P6LPUSH:
	LD	A,(P6TKEYPUSH)
	OR	A
	JR	NZ,P6LRELEASE

	CALL	GETKEYP6T
	LD	(REG_KEYDAT),A
	LD	(KEYTIMER),HL

	LD	A,01H
	LD	(P6TKEYPUSH),A
	LD	(REG_KEYENB),A

	RET

P6LRELEASE:
	CALL	GETKEYP6T
	EX	DE,HL
	LD	(KEYTIMER),HL
	LD	A,B
	LD	(P6TBUFPOS),A

	XOR	A
	LD	(P6TKEYPUSH),A
	LD	(REG_KEYENB),A

	RET

;
; get key data and stroke interval from buffer
;
; (P6TBUFFER) <= key data buffer
; (P6TBUFPOS) <= buffer position
;
; RETURN
; A  <= push key data
; HL <= key push wait timer
; DE <= key release wait timer
; B  <= next buffer position
;
GETKEYP6T:
	LD	A,(P6TBUFPOS)
	LD	E,A
	LD	D,00H
	LD	HL,P6TBUFFER
	ADD	HL,DE
	LD	A,(HL)
	LD	C,A

	LD	A,(P6TBUFPOS)
	CP	05H
	JR	NZ,GKPL1

		;
		; BASIC MODE
		;
	LD	A,(REG_MK2MODE)
	OR	A
	JR	NZ,GKPL_MK2

	LD	A,C
	OR	A
	JR	Z,GKPL0
	CP	05H
	JR	NC,GKPL0

	AND	01H
	LD	(REG_MEM16K),A
		;
	LD	HL,REG_CTRLRST
	LD	(HL),01H
	LD	(HL),00H

GKPL0:
	LD	B,06H
	LD	HL,0100H
	LD	DE,1000H
	XOR	A
	RET

GKPL_MK2:
	LD	B,06H
	LD	A,C
	ADD	A,30H
	LD	HL,0100H
	LD	DE,1000H
	RET

GKPL1:
	CP	06H
	JR	NZ,GKPL2
		;
		; Pages
		;
	LD	B,07H
	LD	A,C
	ADD	A,30H
	LD	HL,0100H
	LD	DE,0100H
	RET

GKPL2:
	CP	07H
	JR	NZ,GKPL3
		;
		; Pages (return)
		;
	LD	B,09H
	LD	A,0DH
	LD	HL,0100H
	LD	DE,2000H
	RET

GKPL3:
	LD	B,A
	INC	B
	LD	HL,0100H
	LD	DE,0100H

	LD	A,0AH
	CP	C
	JR	NZ,GKPL4

	LD	DE,1000H
	LD	A,0DH
	RET

GKPL4:
	LD	A,0DH
	CP	C
	JR	NZ,GKPL5
	LD	DE,1000H
GKPL5:
	LD	A,C
	RET

;
; read auto command from p6t file
;
; RETURN
; A <= P6T flag (01H:auto command 00H:no command)
; (P6TBUFFER) <= key data buffer
; (P6TCMDLEN) <= command length
;
READP6T:

		;
		; (IY+CMTPTR) <= (IY+CMTLEN) - 4
		;
	LD	A,(IY+FIFO_CMTLEN+0)
	SUB	04H
	LD	(IY+FIFO_CMTPTR+0),A
	LD	A,(IY+FIFO_CMTLEN+1)
	SBC	A,00H
	LD	(IY+FIFO_CMTPTR+1),A
	LD	A,(IY+FIFO_CMTLEN+2)
	SBC	A,00H
	LD	(IY+FIFO_CMTPTR+2),A
	LD	A,(IY+FIFO_CMTLEN+3)
	SBC	A,00H
	LD	(IY+FIFO_CMTPTR+3),A

	LD	A,04H
	CALL	FILEPOSREAD
	OR	A
	JR	Z,RP6T_NG

	LD	HL,P6TBUFFER
	LD	A,(HL)
	LD	(IY+FIFO_CMTPTR+0),A
	INC	HL
	LD	A,(HL)
	LD	(IY+FIFO_CMTPTR+1),A
	INC	HL
	LD	A,(HL)
	LD	(IY+FIFO_CMTPTR+2),A
	INC	HL
	LD	A,(HL)
	LD	(IY+FIFO_CMTPTR+3),A

	LD	A,4AH
	CALL	FILEPOSREAD
	OR	A
	JR	Z,RP6T_NG

	LD	HL,P6TBUFFER
		;
		; 0000H identify0 = "P"
		;
	LD	A,(HL)
	CP	'P'
	JR	NZ,RP6T_NG

		;
		; 0001H identify1 = "6"
		;
	INC	HL
	LD	A,(HL)
	CP	'6'
	JR	NZ,RP6T_NG

		;
		; 0002H version = 02H
		;
	INC	HL
	LD	A,(HL)
	CP	02H
	JR	NZ,RP6T_NG

		;
		; 0004H auto command enable = 01H
		;
	INC	HL
	INC	HL
	LD	A,(HL)
	CP	01H
	JR	NZ,RP6T_NG

		;
		; 0007H command length(low)
		;
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	AND	3FH
	ADD	A,09H
	LD	(P6TCMDLEN),A

	LD	A,01H
	RET

RP6T_NG:
	XOR	A
	LD	(P6TCMDLEN),A
	RET

;
; external floppy disk access
;
EXTDISKWAIT:
	LD	A,(EXTFDDST)
	OR	A
	JR	NZ,EXTST01H

		;
		; EXTFDDST:00H - 03H
		; command receive phase
		;

		;
		; wait ATN ON
		;
	LD	A,(REG_EXTFDDCIO)
	AND	08H			; wait ATN ON
	RET	Z
	LD	A,0BH
	LD	(REG_EXTFDDCNT),A	; set RFD
	LD	A,01H
	LD	(EXTFDDST),A
	RET

EXTST01H:
	CP	01H
	JR	NZ,EXTST02H

		;
		; wait ATN OFF
		;
	LD	A,(REG_EXTFDDCIO)
	AND	08H			; wait ATN OFF
	RET	NZ
	LD	A,02H
	LD	(EXTFDDST),A
	RET

EXTST02H:
	CP	02H
	JR	NZ,EXTST03H

		;
		; wait DAV ON
		;
	LD	A,(REG_EXTFDDCIO)
	AND	01H			; wait DAV ON
	RET	Z
	LD	A,0AH
	LD	(REG_EXTFDDCNT),A	; reset RFD
	LD	A,(REG_EXTFDDDI)
	LD	(EXTFDDCMD),A
	LD	A,0DH
	LD	(REG_EXTFDDCNT),A	; set DAC
	LD	A,03H
	LD	(EXTFDDST),A
	RET

EXTST03H:
	CP	03H
	JR	NZ,EXTST10H

		;
		; wait DAV OFF
		;
	LD	A,(REG_EXTFDDCIO)
	AND	01H			; wait DAV OFF
	RET	NZ
	LD	A,0CH
	LD	(REG_EXTFDDCNT),A	; reset DAC
	LD	A,10H
	LD	(EXTFDDST),A
	RET


EXTST10H:
	CP	10H
	JR	NZ,EXTST20H

		;
		; EXTFDDST:10H
		; command analyze phase
		; (detect parameter send/receive length)
		;

		;
		; analyze command
		;
	XOR	A
	LD	(EXTFDDRLEN),A
	LD	(EXTFDDSLEN),A
	LD	(EXTFDDSUBST),A
	LD	(EXTFDDST),A
	LD	A,(EXTFDDCMD)
	CP	08H
	RET	NC

	LD	L,A
	LD	H,00H
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,EXTFDDCMDTBL
	ADD	HL,DE
	LD	A,(HL)
	LD	(EXTFDDRLEN),A
	INC	HL
	LD	A,(HL)
	LD	(EXTFDDSLEN),A
	INC	HL
	LD	A,(HL)
	LD	(EXTFDDSUBAD),A
	INC	HL
	LD	A,(HL)
	LD	(EXTFDDSUBAD+1),A
	LD	A,20H
	LD	(EXTFDDST),A
	RET

EXTST20H:
	CP	20H
	JR	NZ,EXTST30H

		;
		; EXTFDDST:20H
		; command execute
		; (generate output parameter)
		;
	LD	A,30H
	LD	(EXTFDDST),A
	LD	HL,EXTFDDPARA
	LD	(EXTFDDPTR),HL

	LD	A,(EXTFDDCMD)
	CP	03H
	JR	NZ,EXTCMDL1

		;
		; 03H : Transfer Buffer
		;
	LD	HL,EXTRDBUF
	LD	(EXTFDDPTR),HL
	RET

EXTCMDL1:
	CP	06H
	JR	NZ,EXTCMDL2

		;
		; 06H : Command Status
		;
	LD	A,(EXTFDDRDFLAG)
	LD	(EXTFDDPARA),A
	RET

EXTCMDL2:
	CP	07H
	JR	NZ,EXTCMDL3

		;
		; 07H : Drive Status
		;
	LD	A,(REG_FDD3)	; drive #1
	AND	01H
	ADD	A,A
	LD	B,A
	LD	A,(REG_FDD2)	; drive #0
	AND	01H
	OR	B
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	(EXTFDDPARA),A
	RET

EXTCMDL3:
	CP	08H
	JR	NZ,EXTCMDL4

		;
		; 08H : Test Memory
		;
	LD	A,80H
	LD	(EXTFDDPARA),A
	RET

EXTCMDL4:
	CP	10H
	JR	NZ,EXTCMDL5

		;
		; 10H : Load and Go
		;
	XOR	A
	LD	(EXTFDDST),A
	RET

EXTCMDL5:
	RET

EXTST30H:
	CP	30H
	JR	NZ,EXTST31H

		;
		; EXTFDDST:30H - 32H
		; parameter receive phase
		;

	LD	A,(EXTFDDRLEN)
	CP	80H
	JR	Z,EXTST30DATA
	OR	A
	JR	NZ,EXTST30L1
	LD	A,40H
	LD	(EXTFDDST),A
	RET

EXTST30L1:
	LD	A,0BH
	LD	(REG_EXTFDDCNT),A	; set RFD
	LD	A,31H
	LD	(EXTFDDST),A
	RET


EXTST31H:
	CP	31H
	JR	NZ,EXTST32H

		;
		; wait DAV ON
		;
	LD	A,(REG_EXTFDDCIO)
	AND	01H			; wait DAV ON
	RET	Z
	LD	A,0AH
	LD	(REG_EXTFDDCNT),A	; reset RFD
	LD	A,(REG_EXTFDDDI)
	LD	HL,(EXTFDDPTR)
	LD	(HL),A
	INC	HL
	LD	(EXTFDDPTR),HL
	LD	A,0DH
	LD	(REG_EXTFDDCNT),A	; set DAC
	LD	A,32H
	LD	(EXTFDDST),A
	RET

EXTST32H:
	CP	32H
	JR	NZ,EXTST40H

		;
		; wait DAV OFF
		;
	LD	A,(REG_EXTFDDCIO)
	AND	01H			; wait DAV OFF
	RET	NZ
	LD	A,0CH
	LD	(REG_EXTFDDCNT),A	; reset DAC
	LD	A,(EXTFDDRLEN)
	DEC	A
	LD	(EXTFDDRLEN),A
	LD	A,30H
	LD	(EXTFDDST),A
	RET


EXTST30DATA:
	LD	A,(EXTFDDCMD)
	CP	01H
	JR	NZ,EXTST30DATA_L0

		;
		; 01H : Write Disk
		;
	LD	HL,EXTWRBUF
	LD	(EXTFDDPTR),HL
	LD	A,(EXTFDDPARA)
	LD	B,A
	LD	C,00H
	LD	(EXTFDDDTLEN),BC

EXTST30DATA_L0:
	XOR	A
	LD	(EXTFDDRLEN),A
	LD	A,40H
	LD	(EXTFDDST),A
	LD	BC,(EXTFDDDTLEN)
	LD	HL,(EXTFDDPTR)
EXTST30DATA_L1:
	LD	A,B
	OR	C
	RET	Z

	LD	A,0BH
	LD	(REG_EXTFDDCNT),A	; set RFD
EXTST30DATA_L2:
	LD	A,(REG_EXTFDDCIO)
	AND	01H			; wait DAV ON
	JR	Z,EXTST30DATA_L2
	LD	A,0AH
	LD	(REG_EXTFDDCNT),A	; reset RFD
	LD	A,(REG_EXTFDDDI)
	LD	(HL),A
	INC	HL
	LD	A,0DH
	LD	(REG_EXTFDDCNT),A	; set DAC
EXTST30DATA_L3:
	LD	A,(REG_EXTFDDCIO)
	AND	01H			; wait DAV OFF
	JR	NZ,EXTST30DATA_L3
	LD	A,0CH
	LD	(REG_EXTFDDCNT),A	; reset DAC
	DEC	BC
	JR	EXTST30DATA_L1


EXTST40H:
	CP	40H
	JR	NZ,EXTST41H

		;
		; EXTFDDST:40H - 43H
		; parameter send phase
		;

	LD	A,(EXTFDDSLEN)
	CP	80H
	JR	Z,EXTST40DATA
	OR	A
	JR	NZ,EXTST40L1

EXTST40LL2:
	LD	A,50H
	LD	(EXTFDDST),A
	RET

EXTST40L1:
	LD	A,41H
	LD	(EXTFDDST),A
	RET



EXTST41H:
	CP	41H
	JR	NZ,EXTST42H

		;
		; wait RFD ON
		;
	LD	A,(REG_EXTFDDCIO)
	AND	02H			; wait RFD ON
	RET	Z
	LD	HL,(EXTFDDPTR)
	LD	A,(HL)
	LD	(REG_EXTFDDDO),A
	INC	HL
	LD	(EXTFDDPTR),HL
	LD	A,09H
	LD	(REG_EXTFDDCNT),A	; set DAV
	LD	A,42H
	LD	(EXTFDDST),A
	RET

EXTST42H:
	CP	42H
	JR	NZ,EXTST43H

		;
		; wait DAC ON
		;
	LD	A,(REG_EXTFDDCIO)
	AND	04H			; wait DAC ON
	RET	Z
	LD	A,08H
	LD	(REG_EXTFDDCNT),A	; reset DAV
	LD	A,43H
	LD	(EXTFDDST),A
	RET

EXTST43H:
	CP	43H
	JR	NZ,EXTST50H

		;
		; wait DAC OFF
		;
	LD	A,(REG_EXTFDDCIO)
	AND	04H			; wait DAC OFF
	RET	NZ
	LD	A,(EXTFDDSLEN)
	DEC	A
	LD	(EXTFDDSLEN),A
	LD	A,40H
	LD	(EXTFDDST),A
	RET


EXTST40DATA:
	XOR	A
	LD	(EXTFDDSLEN),A
	LD	A,50H
	LD	(EXTFDDST),A
	LD	BC,(EXTFDDDTLEN)
	LD	HL,(EXTFDDPTR)
EXTST40DATA_L1:
	LD	A,B
	OR	C
	RET	Z

EXTST40DATA_L2:
	LD	A,(REG_EXTFDDCIO)
	AND	02H			; wait RFD ON
	JR	Z,EXTST40DATA_L2
	LD	A,(HL)
	LD	(REG_EXTFDDDO),A
	INC	HL
	LD	A,09H
	LD	(REG_EXTFDDCNT),A	; set DAV
EXTST40DATA_L3:
	LD	A,(REG_EXTFDDCIO)
	AND	04H			; wait DAC ON
	JR	Z,EXTST40DATA_L3
	LD	A,08H
	LD	(REG_EXTFDDCNT),A	; reset DAV
EXTST40DATA_L4:
	LD	A,(REG_EXTFDDCIO)
	AND	04H			; wait DAC OFF
	JR	NZ,EXTST40DATA_L4
	DEC	BC
	JR	EXTST40DATA_L1



EXTST50H:
	CP	50H
	RET	NZ

		;
		; EXTFDDST:50H
		; command execute
		;
	LD	HL,(EXTFDDSUBAD)
	LD	A,H
	OR	L
	JR	NZ,EXTST50L1

	XOR	A
	LD	(EXTFDDST),A
	RET

EXTST50L1:
	JP	(HL)


;
; external FDC output data
; B <= output data
;
EXTFDCDTIN:

		;
		; wait RQM(b7)=1 DIO(b6)=1
		;
	LD	A,(REG_EXTFDCMAIN)
	XOR	0C0H
	AND	0C0H
	RET	NZ
	LD	HL,(EXTFDCRSTPTR)
	LD	A,(REG_EXTFDCDATA)
	LD	(HL),A
	INC	HL
	LD	(EXTFDCRSTPTR),HL
	LD	HL,EXTFDDSUBST
	INC	(HL)
	RET

;
; external FDC output data
; B <= output data
;
EXTFDCDTOUT:

		;
		; wait RQM(b7)=1 DIO(b6)=0
		;
	LD	A,(REG_EXTFDCMAIN)
	XOR	80H
	AND	0C0H
	RET	NZ
	LD	A,B
	LD	(REG_EXTFDCDATA),A
	LD	HL,EXTFDDSUBST
	INC	(HL)
	RET

;
; external FDC FDINT wait
;
EXTFDCFDINTWAIT:

		;
		; wait FDINT
		;
	LD	A,(REG_FDINT)
	OR	A
	RET	Z
	LD	HL,EXTFDDSUBST
	INC	(HL)
	RET

;
; external FDC bust wait
;
EXTFDCBUSYWAIT:

		;
		; wait FDC no busy(b4) = 0
		; wait FDD no busy(b3-0) = 0000
		;
	LD	A,(REG_EXTFDCMAIN)
	AND	1FH
	RET	NZ
	LD	HL,EXTFDDSUBST
	INC	(HL)
	RET


;
; external FDD intialize process
; (command 00H)
;
EXTCMD00:
	LD	A,(EXTFDDSUBST)
	OR	A
	JR	NZ,EXTCMD00_01H

		;
		; external FDD initialize
		;
	LD	A,80H
	LD	(EXTFDDRDFLAG),A
	LD	A,03H
	LD	(REG_EXTFDD+FDD_DMASIZE),A

		; recalibrate#0-0 (FDD#0)
	LD	HL,EXTFDCRST
	LD	(EXTFDCRSTPTR),HL
	JP	EXTFDCBUSYWAIT

EXTCMD00_01H:
	DEC	A
	JR	NZ,EXTCMD00_02H

		; recalibrate#0-1 (FDD#0)
	LD	B,CMD_RECALB
	JP	EXTFDCDTOUT

EXTCMD00_02H:
	DEC	A
	JR	NZ,EXTCMD00_03H

		; recalibrate#0-2 (FDD#0)
	LD	B,00H
	JP	EXTFDCDTOUT

EXTCMD00_03H:
	DEC	A
	JR	NZ,EXTCMD00_04H

		; recalibrate#0-3 (FDD#0)
	JP	EXTFDCFDINTWAIT

EXTCMD00_04H:
	DEC	A
	JR	NZ,EXTCMD00_05H

		; recalibrate#0-4 (FDD#0)
	JP	EXTFDCBUSYWAIT

EXTCMD00_05H:
	DEC	A
	JR	NZ,EXTCMD00_06H

		; sense inttrupt status#0-5 (FDD#0)
	LD	B,CMD_SENSEINTST
	JP	EXTFDCDTOUT

EXTCMD00_06H:
	DEC	A
	JR	NZ,EXTCMD00_07H

		; read data result #0-6 (ST0)
	JP	EXTFDCDTIN

EXTCMD00_07H:
	DEC	A
	JR	NZ,EXTCMD00_08H

		; read data result #0-7 (PCN)
	JP	EXTFDCDTIN

EXTCMD00_08H:
	DEC	A
	JR	NZ,EXTCMD00_09H

		; recalibrate#1-0 (FDD#0)
	LD	HL,EXTFDCRST
	LD	(EXTFDCRSTPTR),HL
	JP	EXTFDCBUSYWAIT

EXTCMD00_09H:
	DEC	A
	JR	NZ,EXTCMD00_0AH

		; recalibrate#1-1 (FDD#0)
	LD	B,CMD_RECALB
	JP	EXTFDCDTOUT

EXTCMD00_0AH:
	DEC	A
	JR	NZ,EXTCMD00_0BH

		; recalibrate#1-2 (FDD#0)
	LD	B,00H
	JP	EXTFDCDTOUT

EXTCMD00_0BH:
	DEC	A
	JR	NZ,EXTCMD00_0CH

		; recalibrate#1-3 (FDD#0)
	JP	EXTFDCFDINTWAIT

EXTCMD00_0CH:
	DEC	A
	JR	NZ,EXTCMD00_0DH

		; recalibrate#1-4 (FDD#0)
	JP	EXTFDCBUSYWAIT

EXTCMD00_0DH:
	DEC	A
	JR	NZ,EXTCMD00_0EH

		; sense interrupt status#1-5 (FDD#0)
	LD	B,CMD_SENSEINTST
	JP	EXTFDCDTOUT

EXTCMD00_0EH:
	DEC	A
	JR	NZ,EXTCMD00_0FH

		; sense interrupt status#1-6 (ST0)
	JP	EXTFDCDTIN

EXTCMD00_0FH:
	DEC	A
	JR	NZ,EXTCMD00_10H

		; sense interrupt status#1-7 (PCN)
	JP	EXTFDCDTIN

EXTCMD00_10H:
	DEC	A
	JR	NZ,EXTCMD00_11H

		; recalibrate#0-0 (FDD#1)
	LD	HL,EXTFDCRST
	LD	(EXTFDCRSTPTR),HL
	JP	EXTFDCBUSYWAIT

EXTCMD00_11H:
	DEC	A
	JR	NZ,EXTCMD00_12H

		; recalibrate#0-1 (FDD#1)
	LD	B,CMD_RECALB
	JP	EXTFDCDTOUT

EXTCMD00_12H:
	DEC	A
	JR	NZ,EXTCMD00_13H

		; recalibrate#0-2 (FDD#1)
	LD	B,00H
	JP	EXTFDCDTOUT

EXTCMD00_13H:
	DEC	A
	JR	NZ,EXTCMD00_14H

		; recalibrate#0-3 (FDD#1)
	JP	EXTFDCFDINTWAIT

EXTCMD00_14H:
	DEC	A
	JR	NZ,EXTCMD00_15H

		; recalibrate#0-4 (FDD#1)
	JP	EXTFDCBUSYWAIT

EXTCMD00_15H:
	DEC	A
	JR	NZ,EXTCMD00_16H

		; sense interrupt status#0-5 (FDD#1)
	LD	B,CMD_SENSEINTST
	JP	EXTFDCDTOUT

EXTCMD00_16H:
	DEC	A
	JR	NZ,EXTCMD00_17H

		; sense interrupt status#0-6 (ST0)
	JP	EXTFDCDTIN

EXTCMD00_17H:
	DEC	A
	JR	NZ,EXTCMD00_18H

		; sense interrupt status#0-7 (PCN)
	JP	EXTFDCDTIN

EXTCMD00_18H:
	DEC	A
	JR	NZ,EXTCMD00_19H

		; recalibrate#1-0 (FDD#1)
	LD	HL,EXTFDCRST
	LD	(EXTFDCRSTPTR),HL
	JP	EXTFDCBUSYWAIT

EXTCMD00_19H:
	DEC	A
	JR	NZ,EXTCMD00_1AH

		; recalibrate#1-1 (FDD#1)
	LD	B,CMD_RECALB
	JP	EXTFDCDTOUT

EXTCMD00_1AH:
	DEC	A
	JR	NZ,EXTCMD00_1BH

		; recalibrate#1-2 (FDD#1)
	LD	B,00H
	JP	EXTFDCDTOUT

EXTCMD00_1BH:
	DEC	A
	JR	NZ,EXTCMD00_1CH

		; recalibrate#1-3 (FDD#1)
	JP	EXTFDCFDINTWAIT

EXTCMD00_1CH:
	DEC	A
	JR	NZ,EXTCMD00_1DH

		; recalibrate#1-4 (FDD#1)
	JP	EXTFDCBUSYWAIT

EXTCMD00_1DH:
	DEC	A
	JR	NZ,EXTCMD00_1EH

		; sense interrupt status#1-5 (FDD#1)
	LD	B,CMD_SENSEINTST
	JP	EXTFDCDTOUT

EXTCMD00_1EH:
	DEC	A
	JR	NZ,EXTCMD00_1FH

		; sense interrupt status#1-6 (ST0)
	JP	EXTFDCDTIN

EXTCMD00_1FH:
	DEC	A
	JR	NZ,EXTCMD00_20H

		; sense interrupt status#1-7 (PCN)
	JP	EXTFDCDTIN

EXTCMD00_20H:

	XOR	A
	LD	(EXTFDDST),A
	RET

;
; external FDD write disk process
; (command 01H)
; external FDD read disk process
; (command 02H)
;
EXTCMD02:
	LD	A,(EXTFDDSUBST)
	OR	A
	JR	NZ,EXTCMD02_01H

		; seek #0 (wait FDC no busy)
	LD	HL,EXTFDCRST
	LD	(EXTFDCRSTPTR),HL
	JP	EXTFDCBUSYWAIT

EXTCMD02_01H:
	DEC	A
	JR	NZ,EXTCMD02_02H

		; seek #1 (command)
	LD	B,CMD_SEEK
	JP	EXTFDCDTOUT

EXTCMD02_02H:
	DEC	A
	JR	NZ,EXTCMD02_03H

		; seek #2 (hd/us)
	LD	A,(EXTFDDPARA+1)
	AND	01H
	LD	B,A
	JP	EXTFDCDTOUT

EXTCMD02_03H:
	DEC	A
	JR	NZ,EXTCMD02_04H

		; seek #3 (NCN)
		; 1D only
	LD	A,(EXTFDDPARA+2)
	LD	B,A
	JP	EXTFDCDTOUT

EXTCMD02_04H:
	DEC	A
	JR	NZ,EXTCMD02_05H

		; seek #4 (FDINT wait)
	JP	EXTFDCFDINTWAIT

EXTCMD02_05H:
	DEC	A
	JR	NZ,EXTCMD02_06H

		; seek #5 (FDC no busy wait)
	JP	EXTFDCBUSYWAIT

EXTCMD02_06H:
	DEC	A
	JR	NZ,EXTCMD02_07H

		; sense interrupt status#0
	LD	B,CMD_SENSEINTST
	JP	EXTFDCDTOUT

EXTCMD02_07H:
	DEC	A
	JR	NZ,EXTCMD02_08H

		; sense interrupt status#1 (ST0)
	JP	EXTFDCDTIN

EXTCMD02_08H:
	DEC	A
	JR	NZ,EXTCMD02_09H

		; sense interrupt status#2 (PCN)
	JP	EXTFDCDTIN

EXTCMD02_09H:
	DEC	A
	JR	NZ,EXTCMD02_0AH

	LD	C,80H
	LD	A,(EXTFDDPARA+1)	; drive number
	AND	01H
	LD	B,A
	LD	HL,EXTFDCRST
	LD	A,(HL)			; ST0
	AND	0DFH
	XOR	B
	INC	HL
	LD	B,(HL)			; PCN
	XOR	B
	LD	B,A
	LD	A,(EXTFDDPARA+2)	; track number
	XOR	B
	JR	Z,EXTCMD02_SIL1
	LD	C,81H
	LD	A,C
	LD	(EXTFDDRDFLAG),A
	XOR	A
	LD	(EXTFDDST),A
	RET

EXTCMD02_SIL1:
	LD	HL,EXTFDDSUBST
	INC	(HL)
	RET


EXTCMD02_0AH:
	DEC	A
	JR	NZ,EXTCMD02_0BH

		; read/write data #0 (wait FDC no busy)
	LD	HL,EXTFDCRST
	LD	(EXTFDCRSTPTR),HL
	JP	EXTFDCBUSYWAIT

EXTCMD02_0BH:
	DEC	A
	JR	NZ,EXTCMD02_0CH

		; read/write data #1 (command)
	LD	B,CMD_MFMRDDATA
	LD	A,(EXTFDDCMD)
	CP	02H
	JP	Z,EXTFDCDTOUT

	LD	B,CMD_MFMWRDATA
	JP	EXTFDCDTOUT

EXTCMD02_0CH:
	DEC	A
	JR	NZ,EXTCMD02_0DH

		; read/write data #2 (hd/us)
		; 1D only
	LD	A,(EXTFDDPARA+1)
	AND	01H
	LD	B,A
	JP	EXTFDCDTOUT

EXTCMD02_0DH:
	DEC	A
	JR	NZ,EXTCMD02_0EH

		; read/write data #3 (C)
	LD	A,(EXTFDDPARA+2)
	LD	B,A
	JP	EXTFDCDTOUT

EXTCMD02_0EH:
	DEC	A
	JR	NZ,EXTCMD02_0FH

		; read/write data #4 (H)
	LD	B,00H
	JP	EXTFDCDTOUT

EXTCMD02_0FH:
	DEC	A
	JR	NZ,EXTCMD02_10H

		; read/write data #5 (R)
	LD	A,(EXTFDDPARA+3)
	LD	B,A
	JP	EXTFDCDTOUT

EXTCMD02_10H:
	DEC	A
	JR	NZ,EXTCMD02_11H

		; read/write data #6 (N)
	LD	B,01H
	JP	EXTFDCDTOUT

EXTCMD02_11H:
	DEC	A
	JR	NZ,EXTCMD02_12H

		; read/write data #7 (EOT)
	LD	B,10H
	JP	EXTFDCDTOUT

EXTCMD02_12H:
	DEC	A
	JR	NZ,EXTCMD02_13H

		; read/write data #8 (GOL)
	LD	B,14H
	JP	EXTFDCDTOUT

EXTCMD02_13H:
	DEC	A
	JR	NZ,EXTCMD02_14H

		; read/write data #9 (DTL)
	LD	B,0FFH
	JP	EXTFDCDTOUT

EXTCMD02_14H:
	DEC	A
	JR	NZ,EXTCMD02_15H

		; DMA #0 (DMA on)
	LD	A,(EXTFDDPARA)
	LD	B,A
	LD	A,0FH
	SUB	B
	LD	(REG_EXTFDD+FDD_DMASIZE),A

	LD	B,02H
	LD	A,(EXTFDDCMD)
	CP	02H
	JR	Z,EXTCMD02_14_L1
	LD	B,00H
EXTCMD02_14_L1:
	LD	A,B
	LD	(REG_EXTFDD+FDD_DMACTRL),A
	LD	HL,EXTFDDSUBST
	INC	(HL)
	RET

EXTCMD02_15H:
	DEC	A
	JR	NZ,EXTCMD02_16H

		; DMA #1 (FDINT wait)
	JP	EXTFDCFDINTWAIT

EXTCMD02_16H:
	DEC	A
	JR	NZ,EXTCMD02_17H

		; DMA #2 (DMA off)
	LD	A,03H
	LD	(REG_EXTFDD+FDD_DMACTRL),A
	LD	HL,EXTFDDSUBST
	INC	(HL)
	RET

EXTCMD02_17H:
	SUB	07H
	JR	C,EXTCMD02_17H_L1
	JR	NZ,EXTCMD02_1EH

EXTCMD02_17H_L1:
		; read/write data result #0-6 (ST0-N)
	JP	EXTFDCDTIN

EXTCMD02_1EH:
	LD	A,(EXTFDDPARA)		; sector number
	LD	H,A
	LD	L,00H
	LD	(EXTFDDDTLEN),HL
	LD	A,(EXTFDDPARA+1)	; drive number
	AND	01H
	LD	B,A
	LD	HL,EXTFDCRST
	LD	A,(HL)			; ST0
	AND	0DFH
	XOR	B
	INC	HL
	LD	B,(HL)			; ST1
	OR	B
	INC	HL
	LD	B,(HL)			; ST2
	OR	B

	LD	C,80H
	JR	Z,EXTCMD02_RSL1
	SET	0,C
	XOR	A
	LD	(EXTFDDDTLEN+1),A
EXTCMD02_RSL1:

	LD	A,(EXTFDDCMD)
	CP	02H
	JR	NZ,EXTCMD02_RSL2
	SET	6,C
EXTCMD02_RSL2:

	LD	A,C
	LD	(EXTFDDRDFLAG),A

	XOR	A
	LD	(EXTFDDST),A
	RET

;
; external FDD format
; (command 05H)
;
EXTCMD05:
	LD	A,(EXTFDDSUBST)
	OR	A
	JR	NZ,EXTCMD05_01H

	XOR	A
	LD	(EXTFMTCY),A
	LD	HL,EXTFDDSUBST
	INC	(HL)
	RET

EXTCMD05_01H:
	DEC	A
	JR	NZ,EXTCMD05_02H

		; seek #0 (wait FDC no busy)
	LD	HL,EXTFDCRST
	LD	(EXTFDCRSTPTR),HL
	JP	EXTFDCBUSYWAIT

EXTCMD05_02H:
	DEC	A
	JR	NZ,EXTCMD05_03H

		; seek #1 (command)
	LD	B,CMD_SEEK
	JP	EXTFDCDTOUT

EXTCMD05_03H:
	DEC	A
	JR	NZ,EXTCMD05_04H

		; seek #2 (hd/us)
	LD	A,(EXTFDDPARA)
	AND	01H
	LD	B,A
	JP	EXTFDCDTOUT

EXTCMD05_04H:
	DEC	A
	JR	NZ,EXTCMD05_05H

		; seek #3 (NCN)
		; 1D only
	LD	A,(EXTFMTCY)
	LD	B,A
	JP	EXTFDCDTOUT

EXTCMD05_05H:
	DEC	A
	JR	NZ,EXTCMD05_06H

		; seek #4 (FDINT wait)
	JP	EXTFDCFDINTWAIT

EXTCMD05_06H:
	DEC	A
	JR	NZ,EXTCMD05_07H

		; seek #5 (FDC no busy wait)
	JP	EXTFDCBUSYWAIT

EXTCMD05_07H:
	DEC	A
	JR	NZ,EXTCMD05_08H

		; sense interrupt status#0
	LD	B,CMD_SENSEINTST
	JP	EXTFDCDTOUT

EXTCMD05_08H:
	DEC	A
	JR	NZ,EXTCMD05_09H

		; sense interrupt status#1 (ST0)
	JP	EXTFDCDTIN

EXTCMD05_09H:
	DEC	A
	JR	NZ,EXTCMD05_0AH

		; sense interrupt status#2 (PCN)
	JP	EXTFDCDTIN

EXTCMD05_0AH:
	DEC	A
	JR	NZ,EXTCMD05_0BH

	LD	C,80H
	LD	A,(EXTFDDPARA)		; drive number
	AND	01H
	LD	B,A
	LD	HL,EXTFDCRST
	LD	A,(HL)			; ST0
	AND	0DFH
	XOR	B
	INC	HL
	LD	B,(HL)			; PCN
	XOR	B
	LD	B,A
	LD	A,(EXTFMTCY)		; track number
	XOR	B
	JR	Z,EXTCMD05_SIL1
	LD	C,81H
	LD	A,C
	LD	(EXTFDDRDFLAG),A
	XOR	A
	LD	(EXTFDDST),A
	RET

EXTCMD05_SIL1:
	LD	HL,EXTWRBUF
	LD	B,10H
	LD	C,01H
	LD	A,(EXTFMTCY)
EXTCMD05_SIL2:
	LD	(HL),A
	INC	HL
	LD	(HL),00H
	INC	HL
	LD	(HL),C
	INC	HL
	LD	(HL),01H
	INC	HL
	INC	C
	DJNZ	EXTCMD05_SIL2

	LD	HL,EXTFDDSUBST
	INC	(HL)
	RET


EXTCMD05_0BH:
	DEC	A
	JR	NZ,EXTCMD05_0CH

		; write ID #0 (wait FDC no busy)
	LD	HL,EXTFDCRST
	LD	(EXTFDCRSTPTR),HL
	JP	EXTFDCBUSYWAIT

EXTCMD05_0CH:
	DEC	A
	JR	NZ,EXTCMD05_0DH

		; write ID #1 (command)
	LD	B,CMD_MFMWRID
	JP	EXTFDCDTOUT

EXTCMD05_0DH:
	DEC	A
	JR	NZ,EXTCMD05_0EH

		; write ID #2 (hd/us)
		; 1D only
	LD	A,(EXTFDDPARA)
	AND	01H
	LD	B,A
	JP	EXTFDCDTOUT

EXTCMD05_0EH:
	DEC	A
	JR	NZ,EXTCMD05_0FH

		; write ID #3 (N)
	LD	B,01H
	JP	EXTFDCDTOUT

EXTCMD05_0FH:
	DEC	A
	JR	NZ,EXTCMD05_10H

		; write ID #4 (SC)
	LD	B,10H
	JP	EXTFDCDTOUT

EXTCMD05_10H:
	DEC	A
	JR	NZ,EXTCMD05_11H

		; write ID #5 (GPL)
	LD	B,33H
	JP	EXTFDCDTOUT

EXTCMD05_11H:
	DEC	A
	JR	NZ,EXTCMD05_12H

		; write ID #6 (D)
	LD	B,0FFH
	JP	EXTFDCDTOUT

EXTCMD05_12H:
	DEC	A
	JR	NZ,EXTCMD05_13H

		; DMA #0 (DMA on)
	LD	A,0EH
	LD	(REG_EXTFDD+FDD_DMASIZE),A
	XOR	A
	LD	(REG_EXTFDD+FDD_DMACTRL),A
	LD	HL,EXTFDDSUBST
	INC	(HL)
	RET

EXTCMD05_13H:
	DEC	A
	JR	NZ,EXTCMD05_14H

		; DMA #1 (FDINT wait)
	JP	EXTFDCFDINTWAIT

EXTCMD05_14H:
	DEC	A
	JR	NZ,EXTCMD05_15H

		; DMA #2 (DMA off)
	LD	A,03H
	LD	(REG_EXTFDD+FDD_DMACTRL),A
	LD	HL,EXTFDDSUBST
	INC	(HL)
	RET

EXTCMD05_15H:
	SUB	07H
	JR	C,EXTCMD05_15H_L1
	JR	NZ,EXTCMD05_1CH

EXTCMD05_15H_L1:
		; read/write data result #0-6 (ST0-N)
	JP	EXTFDCDTIN

EXTCMD05_1CH:
	DEC	A
	JR	NZ,EXTCMD05_1DH

	LD	A,(EXTFDDPARA)		; drive number
	AND	01H
	LD	B,A
	LD	HL,EXTFDCRST
	LD	A,(HL)			; ST0
	AND	0DFH
	XOR	B
	INC	HL
	LD	B,(HL)			; ST1
	OR	B
	INC	HL
	LD	B,(HL)			; ST2
	OR	B

	JR	Z,EXTCMD05_RSL1
	LD	A,81H
	LD	(EXTFDDRDFLAG),A
	XOR	A
	LD	(EXTFDDST),A
	RET

EXTCMD05_RSL1:
	LD	A,80H
	LD	(EXTFDDRDFLAG),A
	LD	HL,EXTFDDSUBST
	INC	(HL)
	RET

EXTCMD05_1DH:

	LD	HL,EXTFMTCY
	INC	(HL)
	LD	A,(HL)
	CP	28H
	JR	NC,EXTCMD05_END

	LD	A,01H
	LD	(EXTFDDSUBST),A
	RET

EXTCMD05_END:
	XOR	A
	LD	(EXTFDDST),A
	RET

;
; floppy disk access
;
DISKWAIT:
	LD	A,(IX+FDD_COMEND)
	OR	A
	JR	NZ,DWL0

	XOR	A
	LD	(IX+FDD_ENDTRG),A
	RET

		;
		; drive number -> IY
		;
DWL0:
	PUSH	IX
	POP	BC
	LD	HL,REG_INTFDD
	OR	A
	SBC	HL,BC
	LD	A,(IX+FDD_DNUM)
	JR	NZ,DWL_EXT
	LD	IY,REG_FIFO_2
	AND	01H
	JR	Z,DWL1
	LD	IY,REG_FIFO_3
	JR	DWL1

DWL_EXT:
	AND	01H
	LD	IY,REG_FIFO_4
	JR	Z,DWL1
	LD	IY,REG_FIFO_5

		;
		; status register clear
		;
DWL1:	LD	B,A
	LD	A,(IX+FDD_HNUM)
	OR	A
	RLA
	RLA
	OR	B
	AND	07H
	LD	(IX+FDD_ST0),A
	XOR	A
	LD	(IX+FDD_ST1),A
	LD	(IX+FDD_ST2),A
		;
		; set CHRN
		;
	LD	A,(IX+FDD_IDRC)
	LD	(IX+FDD_RST_C),A
	LD	A,(IX+FDD_IDRH)
	LD	(IX+FDD_RST_H),A
	LD	A,(IX+FDD_IDRR)
	LD	(IX+FDD_RST_R),A
	LD	A,(IX+FDD_IDRN)
	LD	(IX+FDD_RST_N),A

		;
		; FDD nouse
		;
	LD	A,(IY+FIFO_FDD)
	AND	01H
	JR	NZ,DWL3
	SET	4,(IX+FDD_ST0)
	JP	DISKABEND

		;
		; FLOPPY not insert
		;
DWL3:	LD	A,(IY+FIFO_FLOPPY)
	AND	01H
	RET	Z

		;
		; Write Protect
		;
	LD	DE,EXTRDBUF
	LD	A,(IX+FDD_COMMAND)
	CP	CMD_WRDATA
	JR	Z,DWL4
	CP	CMD_WRDELDATA
	JR	Z,DWL4
	CP	CMD_WRID
	JR	NZ,DWL5
DWL4:
	LD	A,(REG_SDWP)
	OR	A
	JP	NZ,DW_NOTWRITABLE
	LD	A,(IY+FIFO_FLOPPY)
	AND	08H
	JP	NZ,DW_NOTWRITABLE
DWL52:
	LD	DE,EXTWRBUF

DWL5:
	PUSH	IX
	POP	BC
	LD	HL,REG_INTFDD
	OR	A
	SBC	HL,BC
	JR	NZ,DWL53
	LD	DE,DISKBUF
DWL53:

		;
		; set transfer bytes
		;
	LD	(DMABUFFERADD),DE

	LD	A,(IX+FDD_DMASIZE)
	LD	H,A
	LD	L,00H
	LD	(DMATRANSBYTES),HL

		;
	LD	HL,0FFFFH
	LD	(FDDSECNUM),HL
		;
	XOR	A
	LD	(SECACCFLAG),A

	LD	A,(IX+FDD_COMMAND)
	CP	CMD_RDID
	JP	Z,DW_RDID

	LD	B,02H	; buffer -> P6
	CP	CMD_RDDATA
	JR	Z,DWL6
	CP	CMD_RDDELDATA
	JR	Z,DWL6
	CP	CMD_RDDIA
	JR	Z,DWL6
	LD	B,00H	; P6 -> buffer
DWL6:
		;
		; wait DMA ON
		;
	LD	A,(IX+FDD_DMACTRL)
	AND	03H
	XOR	B
	RET	NZ

	LD	A,(IX+FDD_COMMAND)
	CP	CMD_RDDIA
	JP	Z,DW_RDDIA

		;
		; Read  Data/Read  Deleted Data
		; Write Data/Write Deleted Data
		; Scan Equal
		; Scan Low or Equal/Scan High or Equal
		;

		;
		; first sector
		;
	CALL	DISKOPEN
		;
	LD	B,(IY+FIFO_CNUM)
	LD	A,(IX+FDD_HNUM)
	LD	C,A
		;
	CALL	GETDISKSECADD
	JP	C,DW_NOSEC

	CALL	JMPREADPTR

DWL_LP:

	LD	A,(IX+FDD_COMMAND)
	CP	CMD_WRID
	JR	NZ,DW_NOTWRID

		;
		; write ID
		;
	LD	A,(IY+FIFO_CNUM)
	LD	(IX+FDD_RST_C),A
	LD	A,(IX+FDD_HNUM)
	LD	(IX+FDD_RST_H),A
	LD	A,01H
	LD	(IX+FDD_RST_R),A
	LD	A,(IX+FDD_IDRC)		; sector length
	LD	(IX+FDD_RST_N),A

	LD	B,(IX+FDD_IDRH)		; sector number of 1 track

DW_WRIDLP:
	PUSH	BC
	CALL	FDDWRITEID
	INC	(IX+FDD_RST_R)
	POP	BC
	LD	A,(SECACCFLAG)
	AND	02H
	JP	NZ,DISKEND
	DJNZ	DW_WRIDLP
	JP	DISKEND


DW_NOTWRID:
	CALL	GETSECSTAT
	PUSH	HL

	LD	HL,(FDDSECNUM)
	INC	HL
	LD	A,H
	OR	L
	JR	NZ,DWL7
	LD	(FDDSECNUM),DE
DWL7:
	POP	HL

	LD	A,(SECSTAT)
	CP	0A0H		; ID CRC error
	JP	Z,DW_IDCRCERR

	CP	0E0H		; no ID Address mark
	JP	Z,DW_SECSKIP

	LD	B,A
	LD	A,(SECIDRCOMP)
	OR	A
	JR	Z,DW_SECEQ

		;
		; IDR <> CHRN
		;
	LD	A,(IX+FDD_COMMAND)
	CP	CMD_WRDATA
	JP	Z,DW_SECSKIP
	CP	CMD_WRDELDATA
	JP	Z,DW_SECSKIP

	LD	A,B
	CP	0F0H		; no Data Address Mark
	JP	Z,DW_SECSKIP
	CP	0B0H		; Data CRC Error
	JP	Z,DW_DATACRCERR
	JP	DW_SECSKIP

DW_SECEQ:
		;
		; IDR = CHRN
		;
	LD	A,B
	CP	0F0H		; no Data Address Mark
	JP	Z,DW_NODATA

	LD	A,(IX+FDD_COMMAND)
	CP	CMD_WRDATA
	JR	Z,DW_WR_WRDEL
	CP	CMD_WRDELDATA
	JR	Z,DW_WR_WRDEL

	BIT	0,(IX+FDD_MT)	; SK
	JR	Z,DWL8
	LD	A,(SECDELCOMP)
	OR	A		; equal Deleted Mark
	JR	Z,DWL8

	SET	6,(IX+FDD_ST2)
	JP	DW_SECSKIP

DWL8:
	LD	A,(IX+FDD_COMMAND)
	CP	CMD_RDDATA
	JR	Z,DW_RD_RDDEL
	CP	CMD_RDDELDATA
	JR	Z,DW_RD_RDDEL
	JP	DISKABEND

		;
		; write data / write deleted data
		;
DW_WR_WRDEL:
	LD	BC,0FFFFH
	LD	DE,0FFF0H
	PUSH	HL
	CALL	MOVEREADPTR

	LD	B,00H
	LD	A,(IX+FDD_COMMAND)
	CP	CMD_WRDATA
	JR	Z,DW_WR_WRDEL_L1
	LD	B,10H
DW_WR_WRDEL_L1:
	LD	A,B
	LD	(SECHEADER_DM),A

		;
		; write Deleted Mark
		;
	CALL	SETSECSTAT

		;
	POP	HL
	CALL	FDDWRITESEC
	JR	DW_RWEND

		;
		; read data / read deleted data
		;
DW_RD_RDDEL:
	CALL	FDDREADSEC

	LD	A,(SECSTAT)
	CP	0B0H		; Data CRC Error
	JP	Z,DW_DATACRCERR
	LD	A,(SECDELCOMP)
	OR	A		; equal Deleted Mark
	JP	NZ,DW_DELETEDMARK
	JR	DW_RWEND


DW_RWEND:
	LD	A,(IX+FDD_EOT)
	LD	B,A
	LD	A,(IX+FDD_RST_R)
	CP	B
	JR	Z,DWL91

		;
		; R <> EOT
		;
	INC	A
	LD	(IX+FDD_RST_R),A

	LD	A,(SECACCFLAG)
	AND	02H
	JP	NZ,DISKEND
	JR	DW_SECEND

DWL91:
		;
		; R = EOT
		;
	LD	A,01H
	LD	(IX+FDD_RST_R),A

	BIT	2,(IX+FDD_MT)
	JR	Z,DW_CYEND

	LD	A,(IX+FDD_RST_H)
	XOR	01H
	LD	(IX+FDD_RST_H),A

	LD	A,(IX+FDD_HNUM)
	OR	A
	JR	Z,DW_SECEND

DW_CYEND:
		;
		; C <= +1
		;
	LD	A,(IX+FDD_RST_C)
	INC	A
	LD	(IX+FDD_RST_C),A

	LD	A,(SECACCFLAG)
	CP	01H
	JR	Z,DW_ENDCY

	LD	A,(SECACCFLAG)
	AND	02H
	JP	NZ,DISKEND

	LD	A,(COMPCY)
	CP	01H
	JR	Z,DW_BADCY
	CP	02H
	JR	Z,DW_WRONGCY
	JR	DW_NOSEC

DW_SECSKIP:
	CALL	FDDSECSKIP

DW_SECEND:
	LD	HL,(FDDSECNUM)
	DEC	HL
	LD	(FDDSECNUM),HL
	LD	A,H
	OR	L
	JP	NZ,DWL_LP

	JR	DW_NOSEC


DW_RDDIA:
DW_RDID:
	JR	DISKABEND

DW_NOTWRITABLE:
	SET	1,(IX+FDD_ST1)
	JR	DISKABEND

DW_NODATA:
	SET	0,(IX+FDD_ST1)
	SET	0,(IX+FDD_ST2)
	JR	DISKABEND

DW_DELETEDMARK:
	SET	6,(IX+FDD_ST2)
	JR	DISKABEND

DW_DATACRCERR:
	SET	5,(IX+FDD_ST1)
	SET	5,(IX+FDD_ST2)
	JR	DISKABEND

DW_IDCRCERR:
	SET	5,(IX+FDD_ST1)
	JR	DISKABEND

DW_ENDCY:
	SET	7,(IX+FDD_ST1)
	JR	DISKABEND

DW_BADCY:
	SET	1,(IX+FDD_ST2)
	JR	DW_NOSEC

DW_WRONGCY:
	SET	4,(IX+FDD_ST2)

DW_NOSEC:
	SET	2,(IX+FDD_ST1)

DISKABEND:
	SET	6,(IX+FDD_ST0)

DISKEND:
	XOR	A
	LD	(REG_SDCTRL),A
	INC	A
	LD	(IX+FDD_ENDTRG),A

	RET

DISKOPEN:
	LD	A,01H
	LD	(REG_SDCTRL),A
	LD	D,04H
	PUSH	IX
	POP	BC
	LD	HL,REG_INTFDD
	OR	A
	SBC	HL,BC
	JR	Z,DISKOPEN_L1
	LD	B,06H
DISKOPEN_L1:
	LD	A,(IX+FDD_DNUM)
	ADD	A,D
	LD	(REG_BUFAD),A
	LD	A,01H
	LD	(REG_BUFSEL),A
	RET


;
; get disk sector address
; (REG_BUFAD) <= use FIFO number
; IY <= use FIFO number
; B <= Cylinder number
; C <= Head number
;
;
; RETURN :
; BCDE  <= disk sector address
; Cflag <= 1 (no found sector address)
;
GETDISKSECADD:
	LD	A,(IY+FIFO_CMTLEN+0)
	OR	(IY+FIFO_CMTLEN+1)
	OR	(IY+FIFO_CMTLEN+2)
	OR	(IY+FIFO_CMTLEN+3)
	SCF
	RET	Z

	LD	A,(IY+FIFO_FDD)
	AND	02H
	JR	Z,GDL_FDD1D

	LD	A,(IY+FIFO_FLOPPY)
	AND	02H
	JR	NZ,GDL_X1
	SLA	B
	JR	GDL_X1

GDL_FDD1D:
	LD	A,(IY+FIFO_FLOPPY)
	AND	02H
	JR	Z,GDL_X1
	SRL	B
	RET	C

		;
		; calc address offset
		;
GDL_X1:
	LD	H,00H
	LD	L,B
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	A,C
	AND	01H
	ADD	A,A
	ADD	A,A
	LD	E,A
	LD	D,00H
	ADD	HL,DE
	LD	E,20H
	ADD	HL,DE

	EX	DE,HL
	LD	BC,0000H
	CALL	JMPREADPTR
		;
	CALL	READ1BYTE
	LD	E,A
	CALL	READ1BYTE
	LD	D,A
	CALL	READ1BYTE
	LD	C,A
	CALL	READ1BYTE
	LD	B,A

	LD	A,B
	OR	C
	OR	D
	OR	E
	SCF
	RET	Z
	OR	A
	RET

; get sector status
; (REG_BUFAD) <= use FIFO number
; IY <= use FIFO number
; read pointer <= sector status address
;
; RETURN :
; read pointer <= sector address
; HL <= sector size
; DE <= sector number
; (SECIDRCOMP) <= result of comparation with IDR and FLOPPY
; (SECDELCOMP) <= result of comparation with DELETED MARK and command
; (SECSTAT)    <= sector status
; (COMPCY)     <= result of comparation with IDR-C and FLOPPY-C
; (SECHEADER)  <= read sector header (16 bytes)
;
GETSECSTAT:

	LD	HL,SECHEADER
	CALL	READ1BYTE	; C
	LD	(HL),A
	INC	HL
	LD	C,A
	XOR	(IX+FDD_RST_C)
	LD	B,A
	JR	Z,GSS_L0
	LD	A,C
	CP	0FFH
	LD	A,01H
	JR	Z,GSS_L0
	LD	A,02H
GSS_L0:
	LD	(COMPCY),A
	CALL	READ1BYTE	; H
	LD	(HL),A
	INC	HL
	XOR	(IX+FDD_RST_H)
	OR	B
	LD	B,A
	CALL	READ1BYTE	; R
	LD	(HL),A
	INC	HL
	XOR	(IX+FDD_RST_R)
	OR	B
	LD	B,A
	CALL	READ1BYTE	; N
	LD	(HL),A
	INC	HL
	XOR	(IX+FDD_RST_N)
	OR	B
	LD	B,A
	CALL	READ1BYTE	; sector number
	LD	(HL),A
	INC	HL
	LD	E,A
	CALL	READ1BYTE	; sector number
	LD	(HL),A
	INC	HL
	LD	D,A
	PUSH	DE

	CALL	READ1BYTE	; FM/MFM
	LD	(HL),A
	INC	HL
	LD	C,A
	LD	A,(IX+FDD_MT)
	CPL
	AND	02H
	RRCA
	RRCA
	RRCA
	XOR	C
	OR	B
	LD	(SECIDRCOMP),A

	LD	C,00H
	LD	A,(IX+FDD_COMMAND)
	CP	CMD_RDDELDATA
	JR	NZ,GSS_L1
	LD	C,10H
GSS_L1:	CALL	READ1BYTE	; DELETED MARK
	LD	(HL),A
	INC	HL
	XOR	C
	LD	(SECDELCOMP),A

	CALL	READ1BYTE	; STATUS
	LD	(HL),A
	INC	HL
	CP	10H
	JR	NZ,GSS_L2
	XOR	A
GSS_L2:	LD	(SECSTAT),A

	LD	B,05H
GSS_L3:	CALL	READ1BYTE	; reserved
	LD	(HL),A
	INC	HL
	DJNZ	GSS_L3

	CALL	READ1BYTE	; sector size
	LD	(HL),A
	INC	HL
	LD	E,A
	CALL	READ1BYTE	; sector size
	LD	(HL),A
	INC	HL
	LD	D,A

	EX	DE,HL
	POP	DE
	RET

; set sector status
; (REG_BUFAD) <= use FIFO number
; IY <= use FIFO number
; read pointer <= sector status address
; (SECHEADER)  <= read sector header (16 bytes)
;
; RETURN :
; read pointer <= sector address
;
SETSECSTAT:

	LD	B,10H
	LD	HL,SECHEADER

SSS_L1:
	LD	A,(HL)
	CALL	WRITE1BYTE
	INC	HL
	DJNZ	SSS_L1

		;
		; 1 sector write
		;
	LD	L,(IY+FIFO_CL+0)
	LD	H,(IY+FIFO_CL+1)
	LD	A,(IY+FIFO_SEC)
	CALL	CALCSDADD
		;
	LD	HL,WORK
	CALL	LD4B_REG_SDADD_MHL
		;
	CALL	WRITE1SEC

	RET



; read sector from FDD
; (REG_BUFAD) <= use FIFO number
; IY <= use FIFO number
; HL <= sector bytes
; read pointer <= sector status address
; (DMABUFFERADD)  <= DMA buffer address
; (DMATRANSBYTES) <= DMA transfer bytes
;
; RETURN :
; read pointer <= sector address
; (DMABUFFERADD)  <= DMA buffer address
; (DMATRANSBYTES) <= DMA transfer bytes
; (SECACCFLAG) <= set flag
;
FDDREADSEC:
	LD	BC,(DMABUFFERADD)
	LD	DE,(DMATRANSBYTES)
FRSL1:
	CALL	READ1BYTE
	LD	(BC),A
	LD	A,B
	AND	0F0H
	CP	DISKBUF_U
	INC	BC
	LD	A,B
	JR	NZ,FRSL2

		; internal FDD (0x9000 - 0x93FF)
	AND	03H
	OR	DISKBUF_U
	JR	FRSL3

FRSL2:
		; external FDD (0xB000 - 0xBFFF)
	AND	0FH
	OR	EXTRDBUF_U

FRSL3:
	LD	B,A

	INC	DE
	LD	A,D
	CP	0FH
	LD	A,03H
	JR	Z,FRS_END

	DEC	HL
	LD	A,H
	OR	L
	JR	NZ,FRSL1

	LD	A,01H

FRS_END:
	LD	(SECACCFLAG),A
	LD	(DMABUFFERADD),BC
	LD	(DMATRANSBYTES),DE
	RET


;
; skip 1 sector
; (REG_BUFAD) <= use FIFO number
; IY <= use FIFO number
; HL <= sector bytes
; read pointer <= sector status address
;
; RETURN :
; read pointer <= sector address
;
FDDSECSKIP:

	EX	DE,HL

FSS_L3:
	LD	L,(IY+FIFO_CMTPTR+0)
	LD	H,(IY+FIFO_CMTPTR+1)
	LD	A,H
	ADD	HL,DE
	JR	C,FSS_L1
	XOR	H
	AND	0FEH
	JR	NZ,FSS_L1

	LD	(IY+FIFO_CMTPTR+0),L
	LD	(IY+FIFO_CMTPTR+1),H
	RET

FSS_L1:
	LD	HL,0200H
	LD	C,(IY+FIFO_CMTPTR+0)
	LD	A,(IY+FIFO_CMTPTR+1)
	AND	01H
	LD	B,A
	OR	A
	SBC	HL,BC

	EX	DE,HL
	OR	A
	SBC	HL,DE
	EX	DE,HL

	XOR	A
	LD	(IY+FIFO_CMTPTR+0),A
	LD	A,(IY+FIFO_CMTPTR+1)
	AND	0FEH
	ADD	A,02H
	LD	(IY+FIFO_CMTPTR+1),A
	LD	A,(IY+FIFO_CMTPTR+2)
	ADC	A,00H
	LD	(IY+FIFO_CMTPTR+2),A
	LD	A,(IY+FIFO_CMTPTR+3)
	ADC	A,00H
	LD	(IY+FIFO_CMTPTR+3),A

	PUSH	DE


		;
		; sector ++
		;
	LD	L,(IY+FIFO_CL+0)
	LD	H,(IY+FIFO_CL+1)
	LD	A,(IY+FIFO_SEC)
	PUSH	HL
	CALL	GET_NEXTSEC
	LD	(IY+FIFO_CL+0),L
	LD	(IY+FIFO_CL+1),H
	LD	(IY+FIFO_SEC),A
		;
	POP	HL
	OR	A
	JR	NZ,FSS_L2
		;
	LD	(IY+FIFO_BEFCL+0),L
	LD	(IY+FIFO_BEFCL+1),H
		;

		;
		; 1 sector read
		;
FSS_L2:
	LD	L,(IY+FIFO_CL+0)
	LD	H,(IY+FIFO_CL+1)
	LD	A,L
	OR	H
	JP	Z,SDERR
	LD	A,(IY+FIFO_SEC)
	CALL	CALCSDADD
		;
	LD	HL,WORK
	CALL	LD4B_REG_SDADD_MHL
		;
	CALL	READ1SEC
		;

	POP	DE
	JP	FSS_L3



; write sector to FDD
; (REG_BUFAD) <= use FIFO number
; IY <= use FIFO number
; HL <= sector bytes
; read(write) pointer <= sector status address
; (DMABUFFERADD)  <= DMA buffer address
; (DMATRANSBYTES) <= DMA transfer bytes
;
; RETURN :
; read(write) pointer <= sector address
; (DMABUFFERADD)  <= DMA buffer address
; (DMATRANSBYTES) <= DMA transfer bytes
; (SECACCFLAG) <= set flag
;
FDDWRITESEC:
	LD	BC,(DMABUFFERADD)
	LD	DE,(DMATRANSBYTES)

FWSL1:
	LD	A,(BC)
	CALL	WRITE1BYTE
	LD	A,B
	AND	0F0H
	CP	DISKBUF_U
	INC	BC
	LD	A,B
	JR	NZ,FWSL2

		; internal FDD (0x9000 - 0x93FF)
	AND	03H
	OR	DISKBUF_U
	JR	FWSL3

FWSL2:
		; external FDD (0xA000 - 0xAFFF)
	AND	0FH
	OR	EXTWRBUF_U

FWSL3:
	LD	B,A

	INC	DE
	LD	A,D
	CP	0FH
	LD	A,03H
	JR	Z,FWS_END

	DEC	HL
	LD	A,H
	OR	L
	JR	NZ,FWSL1

	LD	A,01H

FWS_END:
	LD	(SECACCFLAG),A
	LD	(DMABUFFERADD),BC
	LD	(DMATRANSBYTES),DE

		;
		; 1 sector write
		;
	LD	L,(IY+FIFO_CL+0)
	LD	H,(IY+FIFO_CL+1)
	LD	A,(IY+FIFO_SEC)
	CALL	CALCSDADD
		;
	LD	HL,WORK
	CALL	LD4B_REG_SDADD_MHL
		;
	CALL	WRITE1SEC

	RET


; write ID to FDD
; (REG_BUFAD) <= use FIFO number
; IY <= use FIFO number
; read(write) pointer <= sector status address
; (DMABUFFERADD)  <= DMA buffer address
; (DMATRANSBYTES) <= DMA transfer bytes
; (IX+FDD_IDRC)   <= N   (data length of 1 sector)
; (IX+FDD_IDRH)   <= SC  (sector number of 1 track)
; (IX+FDD_IDRN)   <= D   (data pattern)
;
; RETURN :
; read(write) pointer <= sector address
; (DMABUFFERADD)  <= DMA buffer address
; (DMATRANSBYTES) <= DMA transfer bytes
; (SECACCFLAG) <= set flag
;
FDDWRITEID:
	LD	HL,0004H
	LD	BC,(DMABUFFERADD)
	LD	DE,(DMATRANSBYTES)

FWDL1:
	LD	A,(BC)
	CALL	WRITE1BYTE

	LD	A,B
	AND	0F0H
	CP	DISKBUF_U
	INC	BC
	LD	A,B
	JR	NZ,FWDL2

		; internal FDD (0x9000 - 0x93FF)
	AND	03H
	OR	DISKBUF_U
	JR	FWDL3

FWDL2:
		; external FDD (0xA000 - 0xAFFF)
	AND	0FH
	OR	EXTWRBUF_U

FWDL3:
	LD	B,A

	INC	DE
	LD	A,D
	CP	0FH
	LD	A,03H
	JR	Z,FWDL4
	LD	A,01H
FWDL4:
	LD	(SECACCFLAG),A

	DEC	HL
	LD	A,H
	OR	L
	JR	NZ,FWDL1

	LD	(DMABUFFERADD),BC
	LD	(DMATRANSBYTES),DE

	LD	A,(IX+FDD_IDRH)
	CALL	WRITE1BYTE		; sector number of 1 track
	XOR	A
	CALL	WRITE1BYTE		; sector number of 1 track

	LD	A,(IX+FDD_MT)
	CPL
	AND	02H
	RRCA
	RRCA
	RRCA
	CALL	WRITE1BYTE		; FM/MFM

	LD	B,07H
FWDL5:
	XOR	A
	CALL	WRITE1BYTE		; Deleted Mark / status / reserved x 5
	DJNZ	FWDL5

	LD	B,(IX+FDD_IDRC) 	; sector length
	INC	B
	LD	HL,0040H
FWDL6:
	ADD	HL,HL
	DJNZ	FWDL6
	LD	A,L
	CALL	WRITE1BYTE		; sector length
	LD	A,H
	CALL	WRITE1BYTE		; sector length

FWDL7:
	LD	A,(IX+FDD_IDRN)		; data pattern
	CALL	WRITE1BYTE
	DEC	HL
	LD	A,H
	OR	L
	JR	NZ,FWDL7

		;
		; 1 sector write
		;
	LD	L,(IY+FIFO_CL+0)
	LD	H,(IY+FIFO_CL+1)
	LD	A,(IY+FIFO_SEC)
	CALL	CALCSDADD
		;
	LD	HL,WORK
	CALL	LD4B_REG_SDADD_MHL
		;
	CALL	WRITE1SEC

	RET



;
; offset address
;
OFFSET:		DB	00H,00H,00H,00H

;
; FAT start address
;
FATST:		DB	00H,00H,00H,00H

;
; FAT use sector number
;
FATSEC:		DB	00H,00H

;
; root directory start address
;
ROOTST:		DB	00H,00H,00H,00H

;
; claster start address (claster number is #2)
;
CLASTST:	DB	00H,00H,00H,00H

;
; claster size (x512 byte)
;
CLASTSIZE:	DB	00H

;
; directory start address (temporary)
;
DIRCL:		DB	00H,00H

;
; directory file pointer (temporary)
;
DIRPOS:		DB	00H,00H

;
; 4 byte calc work
;
WORK:		DB	00H,00H,00H,00H
WORK2:		DB	00H,00H,00H,00H
WORK3:		DB	00H,00H,00H,00H
WORK4:		DB	00H,00H,00H,00H

;
; return mode of SD error
;
SDMODE:		DB	00H

;
; read flag
;
; 00H : no selected file
; 01H : selected and no read
; 02H : selected and reading
;
READFLAG	DB	00H

;
; write flag
;
; 00H : no selected file
; 01H : selected and CMTwrite not open
; 02H : selected and CMTwrite open
;
WRITEFLAG	DB	00H

;
; SD write protect latch
;
SDWPFLAG	DB	00H

;
; display page number
;
PAGENUM		DB	00H

;
; befoer page number
;
BEFPAGENUM	DB	00H

;
; display page redraw
;
PAGEREDRAW	DB	00H

;
; cursur redraw
;
CURSORREDRAW	DB	00H

;
; file selecter CMT/EXT.ROM
; CMT load : 04H
; ROM load : 05H
; FDD load : 06H
; CMT save : 0CH
; FDD save : 0EH
;
FILESEL		DB	00H

;
; extend rom on/off
;
EXROMFLAG	DB	00H

;
; search file type
; 00H:file
; 10H:directory
;
SEARCHTYPE	DB	00H

;
; SD insert / eject detect timer
;
SDDETTIMER	DB	00H,00H

;
; external FDD status
;
EXTFDDST	DB	00H

;
; external FDD command
;
EXTFDDCMD	DB	00H

;
; external FDD command receive length
; bit7:data flag
;
EXTFDDRLEN	DB	00H

;
; external FDD command send length
; bit7:data flag
;
EXTFDDSLEN	DB	00H

;
; external FDD command parameter buffer
;
EXTFDDPARA	DB	00H,00H,00H,00H,00H,00H,00H

;
; external FDD command parameter pointer
;
EXTFDDPTR	DW	0000H

;
; external FDD command data length
;
EXTFDDDTLEN	DB	00H,00H

;
; external FDD command table (receive length / send length)
;
EXTFDDCMDTBL	DB	00H,00H		; 00H:Initialize
		DW	EXTCMD00
		DB	84H,00H		; 01H:Write Disk
		DW	EXTCMD02
		DB	04H,00H		; 02H:Read Disk
		DW	EXTCMD02
		DB	00H,80H		; 03H:Transfer Buffer
		DW	0000H
		DB	07H,00H		; 04H:Copy
		DW	0000H
		DB	01H,00H		; 05H:Format
		DW	EXTCMD05
		DB	00H,01H		; 06H:Command Status
		DW	0000H
		DB	00H,01H		; 07H:Drive Status
		DW	0000H

;		DB	00H,01H,00H,00H	; 08H:Test Memory
;		DB	04H,80H,00H,00H	; 09H:Read Memory
;		DB	01H,00H,00H,00H	; 0AH:Port Output
;		DB	04H,80H,00H,00H	; 0BH:Get Memory
;		DB	84H,00H,00H,00H	; 0CH:Set Memory
;		DB	02H,00H,00H,00H	; 0DH:Execute
;		DB	06H,00H,00H,00H	; 0EH:Load Memory
;		DB	06H,00H,00H,00H	; 0FH:Save Memory
;		DB	00H,00H,00H,00H	; 10H:Load and Go

;
; external FDD format cylinder nubmer
;
EXTFMTCY	DB	00H

;
; external FDD command status
; bit7:1 bit6:read flag bit0:error
;
EXTFDDRDFLAG	DB	80H

;
; external FDD sub-routine address
;
EXTFDDSUBAD	DW	0000H

;
; external FDD sub-routine status
;
EXTFDDSUBST	DB	00H

;
; external FDC result
;
EXTFDCRST	DB	00H,00H,00H,00H,00H,00H,00H

;
; external FDC result pointer
;
EXTFDCRSTPTR	DB	00H,00H

;
; FDD sector access number
;
FDDSECNUM	DB	00H,00H

;
; sector access flag
; bit0 : read/write sector
; bit1 : end flag
;
SECACCFLAG	DB	00H

;
; sector compare with IDR and FLOPPY
; 00H : equal
;
SECIDRCOMP	DB	00H

;
; sector compare with DELETED MARK and command
; 00H : equal
;
SECDELCOMP	DB	00H

;
; sector status
; 00H : normal
; A0H : ID CRC error
; B0H : DATA CRC error
; E0H : no ID Address mark
; F0H : no Data Address mark
;
SECSTAT		DB	00H

;
; cylinder compare with IDR-C and FLOPPY-C
; 00H : equal
; 01H : not equal and FLOPPY-C = FFH
; 02H : not equal and FLOPPY-C <> FFH
;
COMPCY		DB	00H

;
; sector header buffer (16 bytes)
; states / reserved x 5 / data size x 2
;
SECHEADER	DB	00H	; C
		DB	00H	; H
		DB	00H	; R
		DB	00H	; N
		DB	00H,00H	; sector number
		DB	00H	; FM/MFM
SECHEADER_DM	DB	00H	; Deleted Mark
		DB	00H	; states
		DB	00H,00H,00H,00H,00H	; reserved
		DB	00H,00H	; data size

;
; DMA transfer bytes
;
DMATRANSBYTES	DB	00H,00H

;
; buffer address
;
DMABUFFERADD	DB	00H,00H

;
; p6t auto command enable
;
P6TCMDENB	DB	00H

;
; p6t auto command enable before
;
P6TCMDENBBEF	DB	00H

;
; p6t file read flag
;
P6TFILEREAD	DB	00H

;
; p6t auto command timer
;
KEYTIMER	DB	00H,00H

;
; p6t auto command length
;
P6TCMDLEN	DB	00H

;
; p6t buffer position
;
P6TBUFPOS	DB	00H

;
; p6t key push flag
;
P6TKEYPUSH	DB	00H

;
; control select register buffer / function key buffer
; key push detect
;
CTRLNOW		DB	00H
FUNCNOW		DB	00H,00H,00H
CTRLBEF		DB	00H
FUNCBEF		DB	00H,00H,00H
CTRLPUSH	DB	00H
FUNCPUSH	DB	00H,00H,00H

;
; cursor position address and length
;
CURSOR_ADD	DB	00H,00H
CURSOR_LEN	DB	00H

;
; claster number buffer x 20 x2
;
FILEPTR_BUF	DB	00H,00H,00H,00H,00H,00H,00H,00H,00H,00H
		DB	00H,00H,00H,00H,00H,00H,00H,00H,00H,00H
		DB	00H,00H,00H,00H,00H,00H,00H,00H,00H,00H
		DB	00H,00H,00H,00H,00H,00H,00H,00H,00H,00H

;
; UART baud rate
;
UART_BAUD	DB	00H

;
; EXPAND KANJI ROM exist flag
;
EXKANJIEXIST	DB	00H

;
; strings
;
ST_PC6001F	DB	009H,00H,"PC-6001F",00H
ST_PC6001FMK2	DB	006H,00H,"PC-6001F Mk2",00H
ST_PC6601F	DB	009H,00H,"PC-6601F",00H
ST_FPGAVER	DB	015H,00H,"FPGA v."
ST_FPGAVER_VAL	DB	"0000",00H
ST_FIRMVER	DB	036H,00H,"F/W v."
ST_FIRMVER_VAL	DB	"0000",00H
ST_CMTREAD	DB	061H,00H, "CMT READ FILE  ["
ST_CMTREAD_VAL	DB	"FFFFFFFF EEE]",00H
ST_CMTREW	DB	081H,00H,"CMT READ FILE REW.[  OK  ]",00H
ST_CMTWRITE	DB	0A1H,00H, "CMT WRITE FILE ["
ST_CMTWRITE_VAL	DB	"FFFFFFFF EEE]",00H
ST_MEMSIZE	DB	0E1H,00H,"RAM SIZE          ["
ST_MEMSIZE_VAL	DB	" 16KB ]",00H
ST_EXROM	DB	001H,01H,"EXPAND ROM     ["
ST_EXROM_VAL	DB	"FFFFFFFF EEE]",00H
ST_EXKANJI	DB	021H,01H,"EXPAND KANJI ROM  [ "
ST_EXKANJI_VAL	DB	" OFF ]",00H
ST_SC4COL	DB	061H,01H,"SCREEN4 COLOR    ["
ST_SC4COL_VAL	DB	"/ ]",00H
ST_UART		DB	081H,01H,"UART SETTING  ["
ST_UART_VAL	DB	"    NO USE   ]",00H

ST_FDD0INTSET		DB	061H,00H, "INT FDD#0 SETTING   ["
ST_FDD0INTSET_VAL	DB	"NO USE]",00H
ST_FDD0INTFILE		DB	081H,00H, "INT FDD#0 FILE   ["
ST_FDD0INTFILE_VAL	DB	"FFFFFFFF EEE]",00H
ST_FDD1INTSET		DB	0A1H,00H, "INT FDD#1 SETTING   ["
ST_FDD1INTSET_VAL	DB	"NO USE]",00H
ST_FDD1INTFILE		DB	0C1H,00H, "INT FDD#1 FILE   ["
ST_FDD1INTFILE_VAL	DB	"FFFFFFFF EEE]",00H
ST_FDD0EXTSET		DB	001H,01H, "EXT FDD#0 SETTING   ["
ST_FDD0EXTSET_VAL	DB	"NO USE]",00H
ST_FDD0EXTFILE		DB	021H,01H, "EXT FDD#0 FILE   ["
ST_FDD0EXTFILE_VAL	DB	"FFFFFFFF EEE]",00H
ST_FDD1EXTSET		DB	041H,01H, "EXT FDD#1 SETTING   ["
ST_FDD1EXTSET_VAL	DB	"NO USE]",00H
ST_FDD1EXTFILE		DB	061H,01H, "EXT FDD#1 FILE   ["
ST_FDD1EXTFILE_VAL	DB	"FFFFFFFF EEE]",00H

ST_P6T		DB	"P6T"


; : :RET :SPC
; :ESC    :F8  :F11
;0123456789ABCDEF0123456789ABCDEF

ST_KEYFUNC1	DB	0C0H,001H
		DB	020H,092H,0E4H,0DEH,093H,03AH,0B6H,0B0H
		DB	0BFH,0D9H,0B7H,0B0H,020H,099H,08FH,0E3H
		DB	092H,03AH,052H,045H,054H,020H,0E2H,097H
		DB	0DEH,0EDH,03AH,053H,050H,043H,020H,000H
ST_KEYFUNC2	DB	0E0H,001H
		DB	020H,0B7H,0ACH,0DDH,0BEH,0D9H,03AH,045H
		DB	053H,043H,020H,020H,020H,020H,095H,0FCH
		DB	0F9H,03AH,046H,038H,020H,020H,0D8H,0BEH
		DB	0AFH,0C4H,03AH,046H,031H,031H,020H,000H

ST_FNAME	DB	00H,00H
ST_FNAME_VAL	DB	"FFFFFFFF EEE",00H

ST_DEBUG	DB	0E0H,01H,"HL:"
ST_DEBUG_VAL	DB	"0000",00H

ST_NOSELECT	DB	03DH,03DH,020H,09EH,0FDH,0E0H
		DB	098H,0E5H,09CH,020H,03DH,03DH	;"==  =="
ST_WRPROTECT	DB	03DH,020H,096H,097H,09AH,0F0H
		DB	020H,097H,0FDH,09CH,020H,03DH	;"=   ="
ST_OFF		DB	" OFF"
ST_ON		DB	" ON "
ST_16		DB	" 16"
ST_32		DB	" 32"
ST_64		DB	" 64"
ST_128		DB	"128"
ST_SC4COL0	DB	0F0H,0E4H,0DEH,0F8H,02FH,0F3H,0F3H,020H	;"/ "
ST_SC4COL1	DB	0F3H,0F3H,02FH,0F0H,0E4H,0DEH,0F8H,020H	;"/ "
ST_SC4COL2	DB	020H,091H,095H,02FH,091H,096H,020H,020H	;" /  "
ST_SC4COL3	DB	020H,091H,096H,02FH,091H,095H,020H,020H	;" /  "
ST_SC4COLOFF	DB	"  OFF   "
ST_UARTBAUD	DB	"    NO USE   "	; 00
		DB	"   150/   600"	; 01
		DB	"   300/  1200"	; 02
		DB	"   600/  2400"	; 03
		DB	"  1200/  4800"	; 04
		DB	"  2400/  9600"	; 05
		DB	"  4800/ 19200"	; 06
		DB	"  9600/ 38400"	; 07
		DB	" 14000/ 56000"	; 08
		DB	" 14400/ 57600"	; 09
		DB	" 19200/ 76800"	; 0A
		DB	" 28800/115200"	; 0B
		DB	" 30720/122880"	; 0C
		DB	" 32000/128000"	; 0D
		DB	" 38400/153600"	; 0E
		DB	" 57600/230400"	; 0F
		DB	" 64000/256000"	; 10
		DB	" 76800/307200"	; 11
		DB	"115200/460800"	; 12
		DB	"128000/512000"	; 13
		DB	"153600/614400"	; 14
		DB	"192000/768000"	; 15
		DB	"230400/921600"	; 16
		DB	"256000/ 1024K"	; 17

ST_NOUSE	DB	"NO USE"
ST_1D		DB	"  1D  "
ST_1DD		DB	"  1DD "
ST_2D		DB	"  2D  "
ST_2DD		DB	"  2DD "

;
; UART baud rate value table
;
TB_UARTBAUD	DB	0FFH,0FFH,0FFH	; 00
		DB	00BH,08BH,002H	; 01
		DB	085H,045H,001H	; 02
		DB	0C3H,0A2H,000H	; 03
		DB	061H,051H,000H	; 04
		DB	0B1H,028H,000H	; 05
		DB	058H,014H,000H	; 06
		DB	02CH,00AH,000H	; 07
		DB	0FAH,006H,000H	; 08
		DB	0C8H,006H,000H	; 09
		DB	016H,005H,000H	; 0A
		DB	064H,003H,000H	; 0B
		DB	02EH,003H,000H	; 0C
		DB	00DH,003H,000H	; 0D
		DB	08BH,002H,000H	; 0E
		DB	0B2H,001H,000H	; 0F
		DB	087H,001H,000H	; 10
		DB	046H,001H,000H	; 11
		DB	0D9H,000H,000H	; 12
		DB	0C3H,000H,000H	; 13
		DB	0A3H,000H,000H	; 14
		DB	082H,000H,000H	; 15
		DB	06DH,000H,000H	; 16
		DB	062H,000H,000H	; 17


;
; page 0 cursor data
;
PAGE0CURDATA	DB	071H,000H,00CH
		DB	094H,000H,006H
		DB	0B1H,000H,00CH
		DB	0D1H,000H,001H	; no menu
		DB	0F4H,000H,006H
		DB	011H,001H,00CH
		DB	034H,001H,006H
		DB	051H,001H,001H	; no menu
		DB	073H,001H,008H
		DB	090H,001H,00DH

;
; page 2 cursor data
;
PAGE2CURDATA	DB	076H,000H,006H
		DB	093H,000H,00CH
		DB	0B6H,000H,006H
		DB	0D3H,000H,00CH
		DB	0F3H,000H,001H
		DB	016H,001H,006H
		DB	033H,001H,00CH
		DB	056H,001H,006H
		DB	073H,001H,00CH
		DB	093H,001H,001H

;
; BASIC-ROM directory name
;
F_ROMDIR	DB	"ROM        "

;
; BASIC-ROM file name
;
F_BASICROM60	DB	"BASICROM60 "
F_CGROM60	DB	"CGROM60 60 "
F_BASICROM62	DB	"BASICROM62 "
F_CGROM62	DB	"CGROM60 62 "
F_CG2ROM62	DB	"CGROM60M62 "
F_KANJIROM62	DB	"KANJIROM62 "
F_VOICEROM62	DB	"VOICEROM62 "
F_BASICROM66	DB	"BASICROM66 "
F_CGROM66	DB	"CGROM60 66 "
F_CG2ROM66	DB	"CGROM66 66 "
F_KANJIROM66	DB	"KANJIROM66 "
F_VOICEROM66	DB	"VOICEROM66 "
F_EXKANJIROM	DB	"EXKANJI ROM"

;
; P6T file buffer (63 + 10 byte)
;
P6TBUFFER
		DB	00H,00H,00H,00H,00H,00H,00H,00H
		DB	00H,00H,00H,00H,00H,00H,00H,00H
		DB	00H,00H,00H,00H,00H,00H,00H,00H
		DB	00H,00H,00H,00H,00H,00H,00H,00H
		DB	00H,00H,00H,00H,00H,00H,00H,00H
		DB	00H,00H,00H,00H,00H,00H,00H,00H
		DB	00H,00H,00H,00H,00H,00H,00H,00H
		DB	00H,00H,00H,00H,00H,00H,00H,00H
		DB	00H,00H,00H,00H,00H,00H,00H,00H
		DB	00H

	END
